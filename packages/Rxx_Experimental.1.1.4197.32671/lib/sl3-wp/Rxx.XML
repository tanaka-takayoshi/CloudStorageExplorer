<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Rxx</name>
  </assembly>
  <members>
    <member name="T:Rxx.Parsers.IParser`2">
      <summary>
            Represents a parser over an enumerable sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
    </member>
    <member name="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Iterates the specified enumerable sequence and applies the parser's grammar, which is defined in 
            terms of the <see cref="P:Rxx.Parsers.IParser`2.Next" /> parser, to generate matches.
            </summary>
      <param name="source">The enumerable sequence to parse.</param>
      <returns>An enumerable sequence of parse results that contain information about the matches.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.IParser`2.StartIndex">
      <summary>
            Gets the index into the sequence at which parsing begins.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.IParser`2.Next">
      <summary>
            Gets a parser with a grammar that matches the next element in the source sequence.
            </summary>
      <remarks>
            A parser's grammar is defined in terms of grammar rules, each of which is defined in terms of the <see cref="P:Rxx.Parsers.IParser`2.Next" /> parser
            or another rule.
            </remarks>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.AmbiguousParser`2">
      <summary>
            Represents an ambiguous parser that begins a parse operation at the current position of the source sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <invariant>parser != null</invariant>
      <invariant>untilCount &gt;= unlimitedCount</invariant>
    </member>
    <member name="T:Rxx.Parsers.Parser`2">
      <summary>
            Represents a parser over an enumerable sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <invariant>parser != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Parser`2.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.Parser`2" /> class for derived classes.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.Parser`2.Parse(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Iterates the specified enumerable sequence and applies the parser's grammar, 
            which is defined by <see cref="P:Rxx.Parsers.Parser`2.Start" />, to generate matches.
            </summary>
      <param name="source">The enumerable sequence to parse.</param>
      <returns>An enumerable sequence of parse results.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Parser`2.StartIndex">
      <summary>
            Gets the index into the sequence at which parsing begins.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_StartIndex" inheritedFromTypeName="IParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Parser`2.Next">
      <summary>
            Gets a parser with a grammar that matches the next element in the source sequence.
            </summary>
      <remarks>
            A parser's grammar is defined in terms of grammar rules, each of which is defined in terms of the <see cref="P:Rxx.Parsers.Parser`2.Next" /> parser
            or another rule.
            </remarks>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Parser`2.Start">
      <summary>
            Gets the parser's grammar as a parser that is defined in terms of the <see cref="P:Rxx.Parsers.Parser`2.Next" /> parser.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.StringParser`1">
      <summary>
            Represents a parser over a <see cref="T:System.String" /> or an enumerable sequence of <see cref="T:System.Char" />.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of characters.</typeparam>
      <invariant>whiteSpace != null</invariant>
      <invariant>insignificantWhiteSpace != null</invariant>
    </member>
    <member name="T:Rxx.Parsers.IStringParser`1">
      <summary>
            Represents a parser over a <see cref="T:System.String" /> or an enumerable sequence of <see cref="T:System.Char" />.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of characters.</typeparam>
    </member>
    <member name="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop characters are parsed and joins them into a <see cref="T:System.String" />, excluding the stop character.
            </summary>
      <param name="stops">The characters at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop character is parsed
            or the sequence ends.</returns>
      <requires>stops != null</requires>
      <requires>stops.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed and joins them into a <see cref="T:System.String" />, excluding the stop word.
            </summary>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires>stopWords != null</requires>
      <requires>stopWords.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.StringComparer,System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed, using the specified <paramref name="comparer" />, and joins them into a <see cref="T:System.String" />, 
            excluding the stop word.
            </summary>
      <param name="comparer">An object that compares subsequences of parsed character strings to stop words.</param>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires>comparer != null</requires>
      <requires>stopWords != null</requires>
      <requires>stopWords.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IStringParser`1.Word(System.String)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters.
            </summary>
      <param name="value">The string of characters to match.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires>!string.IsNullOrEmpty(value)</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IStringParser`1.Word(System.String,System.StringComparer)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters using the 
            specified <paramref name="comparer" />.
            </summary>
      <param name="value">The string of characters to match.</param>
      <param name="comparer">An object that compares subsequences of parsed character strings to the specified <paramref name="value" />.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires>!string.IsNullOrEmpty(value)</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IStringParser`1.Character(System.Char)">
      <summary>
            Creates a parser with a grammar that matches the specified character.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> to match.</param>
      <returns>A parser with a grammar that matches the specified character.</returns>
      <ensures>Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IStringParser`1.Character(System.Func{System.Char,System.Boolean})">
      <summary>
            Creates a parser with a grammar that matches when the specified <paramref name="predicate" />
            returns <see langword="true" /> for any given character.
            </summary>
      <param name="predicate">A function that receives each character and returns whether it will be consumed.</param>
      <returns>A parser with a grammar that matches each character for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires>predicate != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IStringParser`1.Character(System.Globalization.UnicodeCategory)">
      <summary>
            Creates a parser with a grammar that matches each character within the specified 
            <paramref name="category" />.
            </summary>
      <param name="category">The unicode character in which to match characters.</param>
      <returns>A parser with a grammar that matches each character within the specified 
            <paramref name="category" />.</returns>
      <ensures>Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.IStringParser`1.AnyCharacter">
      <summary>
            Gets a parser with a grammar that matches any character.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.IStringParser`1.WhiteSpace">
      <summary>
            Gets a parser with a grammar that matches one or more consecutive whitespace characters according to the 
            rules of <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.IStringParser`1.InsignificantWhiteSpace">
      <summary>
            Gets a parser with a grammar that matches zero or more consecutive insignificant whitespace characters and joins
            them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.StringParser`1" /> class for derived classes.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.AnyCharacterUntil(System.Char[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop characters are parsed and joins them into a <see cref="T:System.String" />, excluding the stop character.
            </summary>
      <param name="stops">The characters at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop character is parsed
            or the sequence ends.</returns>
      <requires>stops != null</requires>
      <requires>stops.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.AnyCharacterUntil(System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed and joins them into a <see cref="T:System.String" />, excluding the stop word.
            </summary>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires>stopWords != null</requires>
      <requires>stopWords.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.AnyCharacterUntil(System.StringComparer,System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed, using the specified <paramref name="comparer" />, and joins them into a <see cref="T:System.String" />, 
            excluding the stop word.
            </summary>
      <param name="comparer">An object that compares subsequences of parsed character strings to stop words.</param>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires>comparer != null</requires>
      <requires>stopWords != null</requires>
      <requires>stopWords.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Word(System.String)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters.
            </summary>
      <param name="value">The string of characters to match.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires>!string.IsNullOrEmpty(value)</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Word(System.String,System.StringComparer)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters using the 
            specified <paramref name="comparer" />.
            </summary>
      <param name="value">The string of characters to match.</param>
      <param name="comparer">An object that compares subsequences of parsed character strings to the specified <paramref name="value" />.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires>!string.IsNullOrEmpty(value)</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Character(System.Char)">
      <summary>
            Creates a parser with a grammar that matches the specified character.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> to match.</param>
      <returns>A parser with a grammar that matches the specified character.</returns>
      <ensures>Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Character(System.Func{System.Char,System.Boolean})">
      <summary>
            Creates a parser with a grammar that matches when the specified <paramref name="predicate" />
            returns <see langword="true" /> for any given character.
            </summary>
      <param name="predicate">A function that receives each character and returns whether it will be consumed.</param>
      <returns>A parser with a grammar that matches each character for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires>predicate != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Character(System.Globalization.UnicodeCategory)">
      <summary>
            Creates a parser with a grammar that matches each character within the specified 
            <paramref name="category" />.
            </summary>
      <param name="category">The unicode character in which to match characters.</param>
      <returns>A parser with a grammar that matches each character within the specified 
            <paramref name="category" />.</returns>
      <ensures>Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.AnyCharacter">
      <summary>
            Gets a parser with a grammar that matches any character.
            </summary>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.WhiteSpace">
      <summary>
            Gets a parser with a grammar that matches one or more consecutive whitespace characters according to the 
            rules of <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.InsignificantWhiteSpace">
      <summary>
            Gets a parser with a grammar that matches zero or more consecutive whitespace characters determined by the 
            <see cref="P:Rxx.Parsers.StringParser`1.InsignificantWhiteSpaceCharacters" /> collection and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.InsignificantWhiteSpaceCharacters">
      <summary>
            Gets a collection of characters that are considered insignificant whitespace for the  
            <see cref="P:Rxx.Parsers.StringParser`1.InsignificantWhiteSpace" /> parser.  
            </summary>
      <getter>
        <ensures>Contract.Result&lt;ICollection&lt;char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.XmlParser`1">
      <summary>
            Represents an XML parser over a <see cref="T:System.String" /> or an enumerable sequence of <see cref="T:System.Char" />.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of XML nodes.</typeparam>
      <invariant>comparer != null</invariant>
      <invariant>id != null</invariant>
      <invariant>tagStart != null</invariant>
      <invariant>tagEnd != null</invariant>
      <invariant>tagName != null</invariant>
      <invariant>attributeDelimiter != null</invariant>
      <invariant>attributeName != null</invariant>
      <invariant>attributeValue != null</invariant>
      <invariant>attribute != null</invariant>
      <invariant>openTag != null</invariant>
      <invariant>closeTag != null</invariant>
      <invariant>text != null</invariant>
      <invariant>comment != null</invariant>
      <invariant>cData != null</invariant>
      <invariant>element != null</invariant>
    </member>
    <member name="T:Rxx.Parsers.IXmlParser`1">
      <summary>
            Represents an XML parser over a <see cref="T:System.String" /> or an enumerable sequence of <see cref="T:System.Char" />.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of XML nodes.</typeparam>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Attribute(System.String)">
      <summary>
            Creates a parser that matches a single XML attribute with the specified <paramref name="name" />.
            </summary>
      <param name="name">The name of the attribute to match.</param>
      <returns>A parser that matches a single XML attribute with the specified <paramref name="name" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified children.
            </summary>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified children.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified attributes and children.
            </summary>
      <remarks>
            IParser is not covariant on TResult in Silverlight because <see cref="T:System.Collections.Generic.IEnumerable`1" /> is not covariant on T.
            For this reason, the <paramref name="content" /> parameter cannot accept attributes.
            </remarks>
      <param name="attributes">The parsers that match the element's attributes.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified attributes and children.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.
            </summary>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.
            </summary>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.</returns>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified children.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified children.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.
            </summary>
      <remarks>
            IParser is not covariant on TResult in Silverlight because <see cref="T:System.Collections.Generic.IEnumerable`1" /> is not covariant on T.
            For this reason, the <paramref name="content" /> parameter cannot accept attributes.
            </remarks>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parsers that match the element's attributes.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, having no attributes
            and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, having no attributes 
            and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">An enumerable sequence containing the names of the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.IXmlParser`1.Text">
      <summary>
            Gets a parser with a grammar that matches all characters, including whitespace, up to the start tag of an element.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.IXmlParser`1.Comment">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;!-- and ending with --&gt;.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.IXmlParser`1.CData">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;![CDATA[ and ending with ]]&gt;.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.IXmlParser`1.AnyContent">
      <summary>
            Gets a parser with a grammar that matches any <see cref="P:Rxx.Parsers.IXmlParser`1.Text" />, <see cref="P:Rxx.Parsers.IXmlParser`1.Comment" /> or <see cref="P:Rxx.Parsers.IXmlParser`1.CData" /> content.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.IXmlParser`1.AnyElement">
      <summary>
            Gets a parser with a grammar that matches an XML element with any attributes or content.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.IXmlParser`1.AnyAttribute">
      <summary>
            Gets a parser with a grammar that matches an XML attribute.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.#ctor(System.Boolean)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.XmlParser`1" /> class with the specified case-sensitivity
            for derived classes.
            </summary>
      <param name="caseSensitive">Indicates whether the comparison behavior used for matching element and attribute names
            must ignore case.</param>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.XmlParser`1" /> class with case-sensitive element and 
            attribute name comparisons for derived classes.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Attribute(System.String)">
      <summary>
            Creates a parser that matches a single XML attribute with the specified <paramref name="name" />.
            </summary>
      <param name="name">The name of the attribute to match.</param>
      <returns>A parser that matches a single XML attribute with the specified <paramref name="name" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified children.
            </summary>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified attributes and children.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified attributes and children.
            </summary>
      <remarks>
            IParser is not covariant on TResult in Silverlight because <see cref="T:System.Collections.Generic.IEnumerable`1" /> is not covariant on T.
            For this reason, the <paramref name="content" /> parameter cannot accept attributes.
            </remarks>
      <param name="attributes">The parsers that match the element's attributes.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified attributes and children.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.
            </summary>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.
            </summary>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.</returns>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified children.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.
            </summary>
      <remarks>
            IParser is not covariant on TResult in Silverlight because <see cref="T:System.Collections.Generic.IEnumerable`1" /> is not covariant on T.
            For this reason, the <paramref name="content" /> parameter cannot accept attributes.
            </remarks>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parsers that match the element's attributes.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, having no attributes
            and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, having no attributes 
            and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">An enumerable sequence containing the names of the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Start">
      <summary>
            Gets the <see cref="P:Rxx.Parsers.XmlParser`1.Schema" /> that is the parser's grammar.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Parser`2.get_Start" inheritedFromTypeName="Parser">Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Schema">
      <summary>
            Gets the parser's grammar as an XML schema that is defined in terms of the parsers created by
            <see cref="P:Rxx.Parsers.XmlParser`1.AnyElement" />, <see cref="P:Rxx.Parsers.XmlParser`1.AnyAttribute" />, <see cref="P:Rxx.Parsers.XmlParser`1.AnyContent" />, <see cref="P:Rxx.Parsers.XmlParser`1.Text" />, 
            <see cref="P:Rxx.Parsers.XmlParser`1.Comment" />, <see cref="P:Rxx.Parsers.XmlParser`1.CData" /> or any of the methods that create parsers with 
            context-sensitive grammars, such as <see cref="M:Rxx.Parsers.XmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" /> and 
            <see cref="M:Rxx.Parsers.XmlParser`1.Attribute(System.String)" /></summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Text">
      <summary>
            Gets a parser with a grammar that matches all characters, including whitespace, up to the start tag of an element.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Comment">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;!-- and ending with --&gt;.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.CData">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;![CDATA[ and ending with ]]&gt;.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.AnyContent">
      <summary>
            Gets a parser with a grammar that matches any <see cref="P:Rxx.Parsers.XmlParser`1.Text" />, <see cref="P:Rxx.Parsers.XmlParser`1.Comment" /> or <see cref="P:Rxx.Parsers.XmlParser`1.CData" /> content.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.AnyElement">
      <summary>
            Gets a parser with a grammar that matches an XML element with any attributes or content.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.AnyAttribute">
      <summary>
            Gets a parser with a grammar that matches an XML attribute.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.IParseResult`1">
      <summary>
            Represents a single result of a parse operation over a sequence.
            </summary>
      <typeparam name="TValue">The type of the parse result's <see cref="P:Rxx.Parsers.IParseResult`1.Value" />.</typeparam>
    </member>
    <member name="P:Rxx.Parsers.IParseResult`1.Value">
      <summary>
            Gets the projection of the matched elements in a sequence.
            </summary>
    </member>
    <member name="P:Rxx.Parsers.IParseResult`1.Length">
      <summary>
            Gets the number of elements in a sequence that were consumed to generate the <see cref="P:Rxx.Parsers.IParseResult`1.Value" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.Linq.ParserExtensions">
      <summary>
            Provides <see langword="static" /> methods for defining <see cref="T:Rxx.Parsers.IParser`2" /> grammars.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Aggregate``4(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``2},System.Func{``2,``1,``2},System.Func{``2,``3})">
      <summary>
            Applies an <paramref name="accumulator" /> function over each result sequence from the 
            specified <paramref name="parser" /> and yields a sequence of accumulated results.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TAccumulate">The type of the accumulation.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from projecting the accumulation.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be aggregated.</param>
      <param name="seed">A function that returns the initial value of the accumulation for each parse result.</param>
      <param name="accumulator">A function to be invoked on each element of each parse result.</param>
      <param name="selector">A function that projects the final aggregation of each parse result.</param>
      <returns>A parser that returns the aggregated results.</returns>
      <requires>parser != null</requires>
      <requires>accumulator != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Join``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Appends each element in each result sequence from the specified <paramref name="parser" /> 
            to an accumulated <see cref="T:System.String" />, yielding a single <see cref="T:System.String" /> per result
            sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be joined into strings.</param>
      <returns>A parser that returns the aggregated <see cref="T:System.String" /> results.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Join``3(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{System.String,``2})">
      <summary>
            Appends each element in each result from the specified <paramref name="parser" /> 
            to an accumulated <see cref="T:System.String" /> and projects the strings for each result.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from projecting the accumulated <see cref="T:System.String" />.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be joined.</param>
      <param name="selector">A function that projects the aggregated <see cref="T:System.String" /> of each parse result.</param>
      <returns>A parser that returns the joined results.</returns>
      <requires>parser != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Join``4(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``1,``2},System.Func{System.String,``3})">
      <summary>
            Applies a <paramref name="joiner" /> function over each result from the specified 
            <paramref name="parser" /> to create an accumulated <see cref="T:System.String" /> and projects 
            the strings for each result.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TJoin">The type of the accumulation on which <see cref="M:System.Object.ToString" /> is called.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from projecting the accumulated <see cref="T:System.String" />.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be joined.</param>
      <param name="joiner">A function to be invoked on each element of each parse result to produce a value 
            on which <see cref="M:System.Object.ToString" /> is called and appended to the accumulation.</param>
      <param name="selector">A function that projects the aggregated <see cref="T:System.String" /> of each parse result.</param>
      <returns>A parser that returns the joined results.</returns>
      <requires>parser != null</requires>
      <requires>joiner != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.NonGreedy``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Converts greedy matches from the specified <paramref name="parser" /> into matches that 
            have a length of zero.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The greedy parser to be made into a non-greedy parser.</param>
      <returns>A parser that converts the greedy matches from the specified <paramref name="parser" /> into 
            matches that have a length of zero.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Maybe``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> or yields success without a value when it does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that might produce matches.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> and 
            an empty enumerable sequence to indicate success when it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Maybe``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Matches the specified <paramref name="parser" /> or yields success without a value when it does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that might produce matches.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> and 
            an empty enumerable sequence to indicate success when it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Ambiguous``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Parses multiple sequences with the specified <paramref name="parser" />, starting from the beginning 
            of the source sequence and then skipping one element at a time, until there are no matches or the 
            source sequence ends.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The unambiguous parser that will parse each consecutive sequence until there are
            no matches or the source sequence ends.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> for each 
            consecutive sequence, starting from the beginning of the source sequence and then skipping one element 
            at a time, until there are no matches or the source sequence ends.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Ambiguous``2(Rxx.Parsers.IParser{``0,``1},System.Int32)">
      <summary>
            Parses multiple sequences with the specified <paramref name="parser" />, starting from the beginning 
            of the source sequence and then skipping one element at a time, until the specified count is reached
            or the source sequence ends.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The unambiguous parser that will parse each consecutive sequence until the specified 
            count is reached or the source sequence ends.</param>
      <param name="untilCount">Indicates the maximum number of ambiguous matches to find.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> for each 
            consecutive sequence, starting from the beginning of the source sequence and then skipping one element 
            at a time, until the specified count is reached or the source sequence ends.</returns>
      <requires>parser != null</requires>
      <requires>untilCount &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Ambiguous``3(Rxx.Parsers.IParser{``0,``2},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Parses multiple sequences with the specified <paramref name="parser" />, starting from the beginning 
            of the source sequence and then skipping one element at a time, until the other parser matches or the 
            source sequence ends.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TUntilResult">The type of the elements that are generated by the until parser.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The unambiguous parser that will parse each consecutive sequence until the other 
            parser matches or the source sequence ends.</param>
      <param name="untilParser">The parser that ends the ambiguity when it matches.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> for each 
            consecutive sequence, starting from the beginning of the source sequence and then skipping one element 
            at a time, until the other parser matches or the source sequence ends.</returns>
      <requires>parser != null</requires>
      <requires>untilParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Amplify``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into a singleton enumerable sequence
            that contains the match's value.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches will be projected into singleton enumerable sequences.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> projected into singleton
            enumerable sequences.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.One``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Matches the single element from the ambiguous result sequence in each match that is yielded by the specified 
            <paramref name="parser" /> and fails for any match in which there is zero or more than one element.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which the single result element is yielded for each match.</param>
      <returns>A parser that matches the single element from the result sequence of each match that is 
            yielded by the specified <paramref name="parser" /> and fails for any match in which there is zero 
            or more than one element.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" /> method 
            for the generated parser.</param>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.String,System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="name">The name of the parser that will appear in diagnostic trace output.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" /> method 
            for the generated parser.</param>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Collections.Generic.IEnumerable{``0},Rxx.Parsers.IParser{``0,``1},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" /> method 
            for the generated parser.</param>
      <remarks>
        <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Collections.Generic.IEnumerable{``0},Rxx.Parsers.IParser{``0,``1},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            is merely a convenience extension that works similar to 
            <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            except that it passes the specified <paramref name="parser" /> to the <paramref name="parse" /> function to facilitate writing 
            iterator blocks that must reference the original parser.
            </remarks>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.String,System.Func{System.Collections.Generic.IEnumerable{``0},Rxx.Parsers.IParser{``0,``1},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="name">The name of the parser that will appear in diagnostic trace output.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" /> method 
            for the generated parser.</param>
      <remarks>
        <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Collections.Generic.IEnumerable{``0},Rxx.Parsers.IParser{``0,``1},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            is merely a convenience extension that works similar to 
            <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            except that it passes the specified <paramref name="parser" /> to the <paramref name="parse" /> function to facilitate writing 
            iterator blocks that must reference the original parser.
            </remarks>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Yield``4(Rxx.Parsers.IParser{``0,``1},System.Func{System.Collections.Generic.IEnumerable{``0},Rxx.Parsers.IParser{``0,``1},``2,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``3}}},``2)">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function and <paramref name="argument" />, starting at the index 
            of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TArgument">The type of the extra argument that is passed to the <paramref name="parse" /> function.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" /> method 
            for the generated parser.</param>
      <param name="argument">Extra data to be passed to the <paramref name="parse" /> function.</param>
      <remarks>
        <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Collections.Generic.IEnumerable{``0},Rxx.Parsers.IParser{``0,``1},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            is merely a convenience extension that works similar to 
            <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            except that it passes the specified <paramref name="parser" /> to the <paramref name="parse" /> function to facilitate writing 
            iterator blocks that must reference the original parser.
            </remarks>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Yield``4(Rxx.Parsers.IParser{``0,``1},System.String,System.Func{System.Collections.Generic.IEnumerable{``0},Rxx.Parsers.IParser{``0,``1},``2,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``3}}},``2)">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function and <paramref name="argument" />, starting at the index 
            of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TArgument">The type of the extra argument that is passed to the <paramref name="parse" /> function.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="name">The name of the parser that will appear in diagnostic trace output.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" /> method 
            for the generated parser.</param>
      <param name="argument">Extra data to be passed to the <paramref name="parse" /> function.</param>
      <remarks>
        <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Collections.Generic.IEnumerable{``0},Rxx.Parsers.IParser{``0,``1},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            is merely a convenience extension that works similar to 
            <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            except that it passes the specified <paramref name="parser" /> to the <paramref name="parse" /> function to facilitate writing 
            iterator blocks that must reference the original parser.
            </remarks>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AsString``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Converts matches from the specified <paramref name="parser" /> into strings.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches will be converted into strings.</param>
      <returns>A parser that yields strings for the matches from the specified <paramref name="parser" />.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Cast``3(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Casts results from the specified <paramref name="parser" /> into the specified type.
            </summary>
      <remarks>
        <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Cast``3(Rxx.Parsers.IParser{``0,``1})" /> is required for Silverlight because it doesn't support covariance on 
            <see cref="T:System.Collections.Generic.IEnumerable`1" />, which is required for <see cref="T:Rxx.Parsers.IParser`2" /> to support covariance on 
            <strong>TResult</strong>.  A consequence is that parsers must sometimes be cast down to their base types before
            they can be combined using various parser operators.
            </remarks>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The original type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TCastResult">The type to which the elements that are generated from parsing the source elements are cast.</typeparam>
      <param name="parser">The parser from which results will be cast into the specified type.</param>
      <returns>A parser that casts results from the specified <paramref name="parser" />.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TCastResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Required``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> if the specified <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> if there are no matches.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Required``2(Rxx.Parsers.IParser{``0,``1},System.String)">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> with the specified message if the specified <paramref name="parser" /> 
            does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <param name="errorMessage">A <see cref="T:System.String" /> that describes the failed expectation to be used as the message 
            in the <see cref="T:Rxx.Parsers.ParseException" />.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> with the specified message if there are no matches.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(errorMessage)</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Required``2(Rxx.Parsers.IParser{``0,``1},System.Func{System.String})">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> with a message returned by the specified function if the specified 
            <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <param name="errorMessageFactory">A function that returns a <see cref="T:System.String" /> describing the failed expectation 
            to be used as the message in the <see cref="T:Rxx.Parsers.ParseException" />.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> with a message returned by the specified functions if there are no matches.</returns>
      <requires>parser != null</requires>
      <requires>errorMessageFactory != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Required``2(Rxx.Parsers.IParser{``0,``1},System.Func{System.Exception})">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> returned by the specified function if the specified 
            <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <param name="exceptionFactory">A function that returns the <see cref="T:Rxx.Parsers.ParseException" /> to be thrown describing the 
            failed expectation.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> returned by the specified functions if there are no matches.</returns>
      <requires>parser != null</requires>
      <requires>exceptionFactory != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Where``2(Rxx.Parsers.IParser{``0,``1},System.Func{``1,System.Boolean})">
      <summary>
            Matches all results from the specified <paramref name="parser" /> for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches will be filtered by the specified <paramref name="predicate" />.</param>
      <param name="predicate">A function that returns <see langword="true" /> to indicate when a match should be yielded and 
            <see langword="false" /> when a match should be ignored.</param>
      <returns>A parser that matches only those results from the specified <paramref name="parser" /> for which 
            the specified <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires>parser != null</requires>
      <requires>predicate != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.IgnoreBefore``3(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``2})">
      <summary>
            Matches the left parser followed by the right parser, but only returns the right parser's matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIgnore">The type of the elements that are generated by the left parser.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated by the right parser.</typeparam>
      <param name="ignoreParser">The parser from which to ignore matches.</param>
      <param name="parser">The parser from which to yield matches.</param>
      <returns>A parser that matches the left parser followed by the right parser, but only returns the 
            right parser's matches.</returns>
      <requires>ignoreParser != null</requires>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.IgnoreTrailing``3(Rxx.Parsers.IParser{``0,``2},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the left parser followed by the right parser, but only returns the left parser's matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIgnore">The type of the elements that are generated by the right parser.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated by the left parser.</typeparam>
      <param name="parser">The parser from which to yield matches.</param>
      <param name="ignoreParser">The parser from which to ignore matches.</param>
      <returns>A parser that matches the left parser followed by the right parser, but only returns the 
            left parser's matches.</returns>
      <requires>parser != null</requires>
      <requires>ignoreParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Of``2(Rxx.Parsers.IParser{``0,``1},``1)">
      <summary>
            Matches all results from the specified <paramref name="parser" /> that equal the specified
            <paramref name="value" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches equivalent to the specified <paramref name="value" /> will be yielded.</param>
      <param name="value">The value to be compared to matches for equality.</param>
      <returns>A parser that matches only those results from the specified <paramref name="parser" /> that equal
            the specified <paramref name="value" />.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Of``2(Rxx.Parsers.IParser{``0,``1},``1,System.Collections.Generic.IEqualityComparer{``1})">
      <summary>
            Matches all results from the specified <paramref name="parser" /> that equal the specified
            <paramref name="value" /> using the specified <paramref name="comparer" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches equivalent to the specified <paramref name="value" /> will be yielded.</param>
      <param name="value">The value to be compared to matches for equality.</param>
      <param name="comparer">The object that compares matches to the specified <paramref name="value" /> for equality.</param>
      <returns>A parser that matches only those results from the specified <paramref name="parser" /> that equal
            the specified <paramref name="value" /> using the specified <paramref name="comparer" />.</returns>
      <requires>parser != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Group``4(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``3},Rxx.Parsers.IParser{``0,``2})">
      <summary>
            Matches the <paramref name="content" /> between the specified <paramref name="open" /> and <paramref name="close" /> parsers.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TOpen">The type of the elements that are generated from parsing the <paramref name="open" /> elements.</typeparam>
      <typeparam name="TClose">The type of the elements that are generated from parsing the <paramref name="close" /> elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the <paramref name="content" /> elements.</typeparam>
      <param name="open">The parser after which the matching of <paramref name="content" /> begins.</param>
      <param name="content">The parser that matches values between the <paramref name="open" /> and <paramref name="close" /> parsers.</param>
      <param name="close">The parser at which the matching of <paramref name="content" /> ends.</param>
      <returns>A parser with a grammar that matches the <paramref name="open" /> parser, followed by the <paramref name="content" /> parser
            and finally the <paramref name="close" /> parser, yielding the results of the <paramref name="content" /> parser only.</returns>
      <requires>open != null</requires>
      <requires>content != null</requires>
      <requires>close != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Group``3(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``2})">
      <summary>
            Matches zero or more values in between the specified <paramref name="open" /> and <paramref name="close" /> parsers.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TOpen">The type of the elements that are generated from parsing the <paramref name="open" /> elements.</typeparam>
      <typeparam name="TClose">The type of the elements that are generated from parsing the <paramref name="close" /> elements.</typeparam>
      <param name="open">The parser after which the group begins.</param>
      <param name="close">The parser at which the group ends.</param>
      <returns>A parser with a grammar that matches the <paramref name="open" /> parser, followed by everything up to the first 
            match of the <paramref name="close" /> parser, yielding the results in between.</returns>
      <requires>open != null</requires>
      <requires>close != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AmbiguousGroup``1(Rxx.Parsers.IParser{``0,``0},Rxx.Parsers.IParser{``0,``0})">
      <summary>
            Matches everything in between the specified <paramref name="open" /> and <paramref name="close" /> parsers, 
            yielding the first unambiguous match as well as everything in between any sub-groups and overlapping groups, 
            extending past the unambiguous match of the <paramref name="close" /> parser, that match the same grammar.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <param name="open">The parser after which the group begins.</param>
      <param name="close">The parser at which the group ends.</param>
      <remarks>
            The same <paramref name="open" /> or <paramref name="close" /> parser may produce multiple matches at the same index.
            </remarks>
      <returns>A parser with a grammar that matches the <paramref name="open" /> parser, followed by everything up to the first 
            match of the <paramref name="close" /> parser, yielding the results in between as well as the results of all ambiguous 
            matches of the group grammar.</returns>
      <requires>open != null</requires>
      <requires>close != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Not``3(Rxx.Parsers.IParser{``0,``2},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> when the specified <paramref name="notParser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TNotResult">The type of the elements that are generated by the <paramref name="notParser" />.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match when the specified <paramref name="notParser" /> does not match.</param>
      <param name="notParser">The parser that when it matches will cause the matches from the specified 
            <paramref name="parser" /> to be ignored.</param>
      <returns>A parser that matches the specified <paramref name="parser" /> when the specified <paramref name="notParser" />
            does not match.</returns>
      <requires>parser != null</requires>
      <requires>notParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Or``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches either the left parser or the right parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that has precedence.</param>
      <param name="nextParser">The parser that is matched if the first <paramref name="parser" /> does not match.</param>
      <returns>A parser that yields the matches from <paramref name="parser" /> if there are any; otherwise, the matches 
            from <paramref name="nextParser" /> are yielded.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Any``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{``0,``1}})">
      <summary>
            Matches the first parser that is successful.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched until one is successful.</param>
      <returns>A parser that yields the matches from the first parser in <paramref name="parsers" /> that is successful.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Any``2(Rxx.Parsers.IParser{``0,``1}[])">
      <summary>
            Matches the first parser that is successful.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched until one is successful.</param>
      <returns>A parser that yields the matches from the first parser in <paramref name="parsers" /> that is successful.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.And``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.And``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.And``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.And``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}},Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.All``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{``0,``1}})">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.All``2(Rxx.Parsers.IParser{``0,``1}[])">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.All``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}}})">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.All``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}}[])">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Parse``2(System.Func{Rxx.Parsers.IParser{``0,``0},Rxx.Parsers.IParser{``0,``1}})">
      <summary>
            Creates a parser from the specified <paramref name="grammar" /> function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="grammar">A function the accepts a parser that acts as a cursor and returns a parser that matches 
            in terms of the cursor.</param>
      <returns>A parser that yields matches from the specified <paramref name="grammar" />.</returns>
      <requires>grammar != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Parse``2(System.Collections.Generic.IEnumerable{``0},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Applies the specified <paramref name="parser" /> to generate matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The enumerable sequence to parse.</param>
      <param name="parser">An object that defines a grammar to be applied to the enumerable sequence to generate matches.</param>
      <returns>An enumerable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Parse``2(System.Collections.Generic.IEnumerable{``0},System.Func{Rxx.Parsers.ParserQueryContext{``0,``0,Rxx.Parsers.IParser{``0,``0}},Rxx.Parsers.ParserQueryContext{``0,``0,Rxx.Parsers.IParser{``0,``1}}})">
      <summary>
            Applies the specified unambiguous parser grammar to generate matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The enumerable sequence to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.Parse(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor
            	let letter = next.Where(char.IsLetter)
            	let number = next.Where(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An enumerable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Parse``2(System.Collections.Generic.IEnumerable{``0},System.Func{Rxx.Parsers.ParserQueryContext{``0,``0,Rxx.Parsers.IParser{``0,``0}},Rxx.Parsers.ParserQueryContext{``0,``0,Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}}}})">
      <summary>
            Applies the specified ambiguous parser grammar to generate matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The enumerable sequence to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.Parse(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor
            	let letter = next.Where(char.IsLetter)
            	let number = next.Where(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An enumerable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.ParseString``1(System.Collections.Generic.IEnumerable{System.Char},System.Func{Rxx.Parsers.StringParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,System.Char}},Rxx.Parsers.StringParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,``0}}})">
      <summary>
            Applies the specified unambiguous <see cref="T:System.String" /> parser grammar to generate matches.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source characters.</typeparam>
      <param name="source">The <see cref="T:System.String" /> or enumerable sequence of <see cref="T:System.Char" /> to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.ParseString(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor or specialized parser functions
            	// that use the cursor
            	let letter = parser.Character(char.IsLetter)
            	let number = parser.Character(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An enumerable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.ParseString``1(System.Collections.Generic.IEnumerable{System.Char},System.Func{Rxx.Parsers.StringParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,System.Char}},Rxx.Parsers.StringParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{``0}}}})">
      <summary>
            Applies the specified ambiguous <see cref="T:System.String" /> parser grammar to generate matches.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source characters.</typeparam>
      <param name="source">The <see cref="T:System.String" /> or enumerable sequence of <see cref="T:System.Char" /> to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.ParseString(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor or specialized parser functions
            	// that use the cursor
            	let letter = parser.Character(char.IsLetter)
            	let number = parser.Character(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An enumerable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.ParseXml``1(System.Collections.Generic.IEnumerable{System.Char},System.Func{Rxx.Parsers.XmlParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,System.Char}},Rxx.Parsers.XmlParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,``0}}})">
      <summary>
            Applies the specified unambiguous XML parser grammar to generate matches.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source XML nodes.</typeparam>
      <param name="source">The <see cref="T:System.String" /> or enumerable sequence of <see cref="T:System.Char" /> to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.ParseXml(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor or specialized parser functions
            	// that use the cursor
            	let widget = parser.Element("widget")
            	// define the grammar in terms of the rules
            	select parser.Element("products", widget.OneOrMore()))]]></code></example>
      <returns>An enumerable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.ParseXml``1(System.Collections.Generic.IEnumerable{System.Char},System.Func{Rxx.Parsers.XmlParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,System.Char}},Rxx.Parsers.XmlParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{``0}}}})">
      <summary>
            Applies the specified ambiguous XML parser grammar to generate matches.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source XML nodes.</typeparam>
      <param name="source">The <see cref="T:System.String" /> or enumerable sequence of <see cref="T:System.Char" /> to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.ParseXml(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor or specialized parser functions
            	// that use the cursor
            	let widget = parser.Element("widget")
            	// define the grammar in terms of the rules
            	select parser.Element("products", widget.OneOrMore()))]]></code></example>
      <returns>An enumerable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Select``4(Rxx.Parsers.ParserQueryContext{``0,``1,``2},System.Func{``2,``3})">
      <summary>
            Enables defining in-line parser grammars using LINQ.
            </summary>
      <typeparam name="TParseSource">The type of the original source elements.</typeparam>
      <typeparam name="TParseResult">The type of the elements that are originally generated from parsing the source elements.</typeparam>
      <typeparam name="TSource">The type of the source elements; typically, this will be an anonymous compiler-generaed type.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The parser query context to be projected.</param>
      <param name="selector">A function that projects the current result of the query context.</param>
      <returns>A new query context that is the projection of the specified query context using the specified <paramref name="selector" />.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ParserQueryContext&lt;TParseSource, TParseResult, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Select``3(Rxx.Parsers.StringParserQueryContext{``0,``1},System.Func{``1,``2})">
      <summary>
            Enables defining in-line parser grammars using LINQ.
            </summary>
      <typeparam name="TParseResult">The type of the elements that are originally generated from parsing the source elements.</typeparam>
      <typeparam name="TSource">The type of the source elements; typically, this will be an anonymous compiler-generaed type.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The parser query context to be projected.</param>
      <param name="selector">A function that projects the current result of the query context.</param>
      <returns>A new query context that is the projection of the specified query context using the specified <paramref name="selector" />.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;StringParserQueryContext&lt;TParseResult, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Select``3(Rxx.Parsers.XmlParserQueryContext{``0,``1},System.Func{``1,``2})">
      <summary>
            Enables defining in-line parser grammars using LINQ.
            </summary>
      <typeparam name="TParseResult">The type of the elements that are originally generated from parsing the source elements.</typeparam>
      <typeparam name="TSource">The type of the source elements; typically, this will be an anonymous compiler-generaed type.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The parser query context to be projected.</param>
      <param name="selector">A function that projects the current result of the query context.</param>
      <returns>A new query context that is the projection of the specified query context using the specified <paramref name="selector" />.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;XmlParserQueryContext&lt;TParseResult, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Select``3(Rxx.Parsers.IParser{``0,``1},System.Func{``1,``2})">
      <summary>
            Projects matches from the specified <paramref name="parser" /> into a new form.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the matches of the specified <paramref name="parser" />.</typeparam>
      <param name="parser">The parser from which matches will be projected by the specified <paramref name="selector" /> function.</param>
      <param name="selector">A transform function to apply to each match.</param>
      <returns>A parser that projects matches from the specified <paramref name="parser" /> into a new form.</returns>
      <requires>parser != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.SelectMany``4(Rxx.Parsers.IParser{``0,``1},System.Func{``1,Rxx.Parsers.IParser{``0,``2}},System.Func{``1,``2,``3})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into another parser, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TSecondResult">The type of the elements that are generated from the projected parsers.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the matches of the projected parsers.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified parser selector function to create 
            the next parser.</param>
      <param name="parserSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each match from the projected parsers.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into another parser, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>parserSelector != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.SelectMany``4(Rxx.Parsers.IParser{``0,``1},System.Func{``1,Rxx.Parsers.IParser{``0,``2}},System.Func{``1,``2,``3},System.Func{Rxx.Parsers.IParseResult{``1},Rxx.Parsers.IParseResult{``2},System.Int32})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into another parser, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TSecondResult">The type of the elements that are generated from the projected parsers.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the matches of the projected parsers.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified parser selector function to create 
            the next parser.</param>
      <param name="parserSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each match from the projected parsers.</param>
      <param name="lengthSelector">A function that returns the length for each pair of projected matches.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into another parser, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>parserSelector != null</requires>
      <requires>resultSelector != null</requires>
      <requires>lengthSelector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.SelectMany``4(Rxx.Parsers.IParser{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``2}},System.Func{``1,``2,``3})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into an enumerable sequence, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TCollection">The type of the elements in the sequences that are projected from the matches.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the projected sequences.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified collection selector function.</param>
      <param name="collectionSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each element from the projected sequences.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into an enumerable sequence, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>collectionSelector != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.SelectMany``4(Rxx.Parsers.IParser{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``2}},System.Func{``1,``2,``3},System.Func{Rxx.Parsers.IParseResult{``1},``2,System.Int32})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into an enumerable sequence, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TCollection">The type of the elements in the sequences that are projected from the matches.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the projected sequences.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified collection selector function.</param>
      <param name="collectionSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each element from the projected sequences.</param>
      <param name="lengthSelector">A function that returns the length for each pair of projected values.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into an enumerable sequence, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>collectionSelector != null</requires>
      <requires>resultSelector != null</requires>
      <requires>lengthSelector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Single``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches only a single match from the specified <paramref name="parser" /> 
            and fails if there is zero or more than one match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which only a single match is expected.</param>
      <returns>A parser that matches only a single match from the specified <paramref name="parser" /> 
            and fails if there is zero or more than one match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AtLeast``2(Rxx.Parsers.IParser{``0,``1},System.Int32)">
      <summary>
            Matches the specified <paramref name="parser" /> consecutively a minimum number of times.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched consecutively a minimum number of times.</param>
      <param name="count">The number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <returns>A parser that consecutively matches the specified <paramref name="parser" /> the minimum 
            number of times specified by <paramref name="count" />.</returns>
      <requires>parser != null</requires>
      <requires>count &gt; 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.None``2(Rxx.Parsers.IParser{``0,``1},``1)">
      <summary>
            Yields success when the specified <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which any match results in failure.</param>
      <param name="successResult">The value that is yielded if the specified <paramref name="parser" /> does not match.</param>
      <returns>A parser that yields failure when the specified <paramref name="parser" /> matches or success when 
            it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.None``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Yields success when the specified <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which any match results in failure.</param>
      <returns>A parser that yields failure when the specified <paramref name="parser" /> matches or 
            an empty sequence to indicate success when it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.None``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Yields success when the specified <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated 
            from parsing the source elements.</typeparam>
      <param name="parser">The parser for which any match results in failure.</param>
      <returns>A parser that yields failure when the specified <paramref name="parser" /> matches or 
            an empty sequence to indicate success when it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.WithDefault``2(Rxx.Parsers.IParser{``0,``1},``1)">
      <summary>
            Matches the specified <paramref name="parser" /> or yields the specified default result if there are 
            no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that might produce matches.</param>
      <param name="defaultResult">The value that is yielded if the specified <paramref name="parser" /> does not match.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> or the specified default result
            if the <paramref name="parser" /> does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.NoneOrMore``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> zero or more times consecutively.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match zero or more times consecutively.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> zero or more times consecutively.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.NoneOrMore``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> zero or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match zero or more times consecutively.</param>
      <param name="separator">The parser that matches between consecutive matches of the specified <paramref name="parser" />.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> zero or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.</returns>
      <requires>parser != null</requires>
      <requires>separator != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.OneOrMore``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> one or more times consecutively.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match one or more times consecutively.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> one or more times consecutively.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.OneOrMore``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> one or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match one or more times consecutively.</param>
      <param name="separator">The parser that matches between consecutive matches of the specified <paramref name="parser" />.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> one or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.</returns>
      <requires>parser != null</requires>
      <requires>separator != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.OnSuccess``2(Rxx.Parsers.IParser{``0,``1},System.Action{Rxx.Parsers.IParseResult{``1}})">
      <summary>
            Invokes the specified <paramref name="action" /> on each result for its side-effects.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which results will be supplied to the specified <paramref name="action" />.</param>
      <param name="action">The method that will be called for each parser result.</param>
      <returns>A new parser that is the same as the specified parser and also inovkes the specified 
            <paramref name="action" /> with each result for its side-effects.</returns>
      <requires>parser != null</requires>
      <requires>action != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.OnFailure``2(Rxx.Parsers.IParser{``0,``1},System.Action)">
      <summary>
            Invokes the specified <paramref name="action" /> for its side-effects if the specified <paramref name="parser" />
            does not yield any results.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which no results will cause the specified <paramref name="action" /> to be invoked.</param>
      <param name="action">Invoked if the <paramref name="parser" /> does not yield any results.</param>
      <returns>A new parser that is the same as the specified parser and also inovkes the specified 
            <paramref name="action" /> for its side-effects if the specified <paramref name="parser" /> does not yield
            any results.</returns>
      <requires>parser != null</requires>
      <requires>action != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Defer``2(System.Func{Rxx.Parsers.IParser{``0,``1}})">
      <summary>
            Defers creation of a parser until the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" /> method is called.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parserFactory">A function that returns the underlying <see cref="T:Rxx.Parsers.IParser`2" /> on which 
            the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" /> method will be called.</param>
      <returns>A parser that defers creation of its underlying parser until the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" /> 
            method is called.</returns>
      <requires>parserFactory != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Success``3(Rxx.Parsers.IParser{``0,``1},``2)">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding the specified scalar <paramref name="result" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the <paramref name="result" />.</typeparam>
      <param name="parser">The parser for which the specified <paramref name="result" /> indicates success.</param>
      <param name="result">The value of the created parser's result.</param>
      <returns>A parser that always returns the specified scalar <paramref name="result" /> with a length 
            of zero, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Success``3(Rxx.Parsers.IParser{``0,``1},``2,System.Int32)">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding the specified scalar <paramref name="result" /> 
            with the specified length.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the <paramref name="result" />.</typeparam>
      <param name="parser">The parser for which the specified <paramref name="result" /> indicates success.</param>
      <param name="result">The value of the created parser's result.</param>
      <param name="length">The length of the created parser's result.</param>
      <returns>A parser that always returns the specified scalar <paramref name="result" /> with the specified 
            length, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Success``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding a single result containing an empty sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which a single empty result sequence is returned to indicate success.</param>
      <returns>A parser that returns a single result containing an empty sequence with a length 
            of zero, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Success``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding a single result containing an empty sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements in the sequences that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which a single empty result sequence is returned to indicate success.</param>
      <remarks>
        <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Success``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})" /> is required as an explicit overload
            because the meaning of the parser's result sequence is special and must not be compounded into a sequence of sequences, 
            which would happen if the <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Success``2(Rxx.Parsers.IParser{``0,``1})" /> overload were to be called
            instead.
            </remarks>
      <returns>A parser that returns a single result containing an empty sequence with a length 
            of zero, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Failure``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Indicates a failure to parse without actually parsing by returning an empty sequence of parse results.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that is to fail.</param>
      <returns>A parser that always returns an empty sequence of parse results, starting from the index at which 
            the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.ParseException">
      <summary>
            Represents errors that occur while parsing a sequence.
            </summary>
      <invariant>sourceIndex &gt;= 0</invariant>
    </member>
    <member name="M:Rxx.Parsers.ParseException.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParseException" /> class with the default <see cref="P:Rxx.Parsers.ParseException.Message" />.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.ParseException.#ctor(System.Int32)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParseException" /> class with the default <see cref="P:Rxx.Parsers.ParseException.Message" />
            and the specified <see cref="P:Rxx.Parsers.ParseException.SourceIndex" />.
            </summary>
      <param name="sourceIndex">The index in the sequence at which the error occurred while parsing.</param>
      <requires>sourceIndex &gt;= 0</requires>
    </member>
    <member name="M:Rxx.Parsers.ParseException.#ctor(System.String)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParseException" /> class with the specified <paramref name="message" />.
            </summary>
      <param name="message">The message that describes the parser error.</param>
    </member>
    <member name="M:Rxx.Parsers.ParseException.#ctor(System.Int32,System.String)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParseException" /> class with the specified <paramref name="message" />
            and <see cref="P:Rxx.Parsers.ParseException.SourceIndex" />.
            </summary>
      <param name="sourceIndex">The index in the sequence at which the error occurred while parsing.</param>
      <param name="message">The message that describes the parser error.</param>
      <requires>sourceIndex &gt;= 0</requires>
    </member>
    <member name="M:Rxx.Parsers.ParseException.#ctor(System.String,System.Exception)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParseException" /> class with the specified <paramref name="message" />
            and <paramref name="innerException" />.
            </summary>
      <param name="message">The message that describes the parser error.</param>
      <param name="innerException">The exception that is the cause of the current exception, or <see langword="null" /> if no inner exception is specified.</param>
    </member>
    <member name="M:Rxx.Parsers.ParseException.#ctor(System.Int32,System.Exception)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParseException" /> class with the default <see cref="P:Rxx.Parsers.ParseException.Message" />
            and the specified <see cref="P:Rxx.Parsers.ParseException.SourceIndex" /> and <paramref name="innerException" />.
            </summary>
      <param name="sourceIndex">The index in the sequence at which the error occurred while parsing.</param>
      <param name="innerException">The exception that is the cause of the current exception, or <see langword="null" /> if no inner exception is specified.</param>
      <requires>sourceIndex &gt;= 0</requires>
    </member>
    <member name="M:Rxx.Parsers.ParseException.#ctor(System.Int32,System.String,System.Exception)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParseException" /> class with the specified <paramref name="message" />, 
            <see cref="P:Rxx.Parsers.ParseException.SourceIndex" /> and <paramref name="innerException" />.
            </summary>
      <param name="sourceIndex">The index in the sequence at which the error occurred while parsing.</param>
      <param name="message">The message that describes the parser error.</param>
      <param name="innerException">The exception that is the cause of the current exception, or <see langword="null" /> if no inner exception is specified.</param>
      <requires>sourceIndex &gt;= 0</requires>
    </member>
    <member name="P:Rxx.Parsers.ParseException.SourceIndex">
      <summary>
            Gets the index in the sequence at which the error occurred while parsing.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.ParseException.Message">
      <summary>
            Gets a message that describes the parser error.
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Exception.get_Message" inheritedFromTypeName="Exception">Contract.Result&lt;string&gt;() != null</ensures>
      </getter>
    </member>
    <member name="F:Rxx.Parsers.ParserCursor`1.getStartIndex">
      <summary>
            Some parsers, such as AnyParser, will throw when reading the StartIndex property unless Parse has 
            been called.  This function allows the start index to be lazily retrieved from the wrapping parser
            so that it doesn't have to be read when the cursor is being constructed.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.Move(System.Int32)">
      <summary>
            Changes the start element of the cursor to the element at the specified number of elements forward.
            </summary>
      <param name="count">The number of elements after the current element at which the start will be positioned.</param>
      <remarks>
            In addition to advancing the start position, this method also frees memory held by elements that are no longer needed.
            </remarks>
      <requires>count &gt;= 0</requires>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.MoveToCurrent">
      <summary>
            Changes the start element of the cursor to the element after the last element that was read.
            </summary>
      <remarks>
            In addition to advancing the start position, this method also frees memory held by elements that are no longer needed.
            </remarks>
      <returns>The number of elements that the cursor moved to reach the current position.</returns>
      <ensures>Contract.Result&lt;int&gt;() &gt;= 0</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.Element.#ctor(System.Collections.Generic.IEnumerator{`0},`0)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParserCursor`1.Element" /> class.
            </summary>
      <param name="enumerator">The enumerator that returned the current value.</param>
      <param name="value">The current value.</param>
      <requires>enumerator != null</requires>
    </member>
    <member name="T:Rxx.Parsers.ParseResult">
      <summary>
            Provides <see langword="static" /> methods for creating <see cref="T:Rxx.Parsers.ParseResult`1" /> objects.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Add``3(Rxx.Parsers.IParseResult{``0},Rxx.Parsers.IParseResult{``1},System.Func{``0,``1,``2})">
      <summary>
            Applies a selector function to two parse results to produce a new parse result.
            The lengths are summed to indicate that the new parse result 
            encompesses both of the specified parse results and that they match consecutively
            in the input sequence.
            </summary>
      <typeparam name="TFirstResult">The type of the first parse result's value.</typeparam>
      <typeparam name="TSecondResult">The type of the second parse result's value.</typeparam>
      <typeparam name="TResult">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The parse result to be combined with <paramref name="secondResult" />.</param>
      <param name="secondResult">The parse result to be combined with <paramref name="firstResult" />.</param>
      <param name="resultSelector">A function that selects a new parse result from the two specified parse results.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> object containing the sum of the specified parse results' 
            lengths and the return value of the <paramref name="resultSelector" /> function.</returns>
      <requires>firstResult != null</requires>
      <requires>secondResult != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Concat``1(Rxx.Parsers.IParseResult{System.Collections.Generic.IEnumerable{``0}},Rxx.Parsers.IParseResult{``0})">
      <summary>
            Concatenates the specified parse result value sequence and scalar parse result value into a new parse result value sequence.
            The lengths are summed to indicate that the new parse result 
            encompesses both of the specified parse results and that they match consecutively
            in the input sequence.
            </summary>
      <typeparam name="TResult">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The parse result value sequence to which <paramref name="secondResult" /> will be concatenated.</param>
      <param name="secondResult">The scalar parse result value to be concatenated to the value of <paramref name="firstResult" />.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> object containing the sum of the specified parse results' lengths and 
            the concatenation of their values.</returns>
      <requires>firstResult != null</requires>
      <requires>firstResult.Value != null</requires>
      <requires>secondResult != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Concat``1(Rxx.Parsers.IParseResult{``0},Rxx.Parsers.IParseResult{System.Collections.Generic.IEnumerable{``0}})">
      <summary>
            Concatenates the specified scalar parse result value and parse result value sequence into a new parse result value sequence.
            The lengths are summed to indicate that the new parse result 
            encompesses both of the specified parse results and that they match consecutively
            in the input sequence.
            </summary>
      <typeparam name="TResult">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The scalar parse result value to which <paramref name="secondResult" /> will be concatenated.</param>
      <param name="secondResult">The parse result value sequence to be concatenated to the value of <paramref name="firstResult" />.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> object containing the sum of the specified parse results' 
            lengths and the concatenation of their values.</returns>
      <requires>firstResult != null</requires>
      <requires>secondResult != null</requires>
      <requires>secondResult.Value != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Concat``1(Rxx.Parsers.IParseResult{System.Collections.Generic.IEnumerable{``0}},Rxx.Parsers.IParseResult{System.Collections.Generic.IEnumerable{``0}})">
      <summary>
            Concatenates the specified parse result value sequences into a new parse result value sequence.
            The lengths are summed to indicate that the new parse result 
            encompesses both of the specified parse results and that they match consecutively
            in the input sequence.
            </summary>
      <typeparam name="TResult">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The parse result value sequence to which <paramref name="secondResult" /> will be concatenated.</param>
      <param name="secondResult">The parse result value sequence to be concatenated to the value sequence of <paramref name="firstResult" />.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> object containing the sum of the specified parse results' 
            lengths and the concatenation of their values.</returns>
      <requires>firstResult != null</requires>
      <requires>firstResult.Value != null</requires>
      <requires>secondResult != null</requires>
      <requires>secondResult.Value != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Create``1(``0,System.Int32)">
      <summary>
            Creates a new <see cref="T:Rxx.Parsers.IParseResult`1" /> instance from the specified 
            <paramref name="value" /> and <paramref name="length" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="value">The projection of elements of a parse operation.</param>
      <param name="length">The number of elements that were consumed in the sequence to generate 
            the specified <paramref name="value" />.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> instance containing the specified 
            <paramref name="value" /> and <paramref name="length" />.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Return``1(``0,System.Int32)">
      <summary>
            Creates a singleton enumerable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" />  
            with the specified <paramref name="value" /> and <paramref name="length" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="value">The projection of elements of a parse operation.</param>
      <param name="length">The number of elements that were consumed in the sequence to generate 
            the specified <paramref name="value" />.</param>
      <returns>A singleton enumerable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" />  
            with the specified <paramref name="value" /> and <paramref name="length" />.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Remainder``2(Rxx.Parsers.IParseResult{``1},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns the remainder of the specified sequence starting from the <see cref="P:Rxx.Parsers.IParseResult`1.Length" /> 
            of the specified <paramref name="result" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> that indicates at which point the remainder of the sequence begins.</param>
      <param name="source">The sequence for which a remainder will be returned.</param>
      <returns>The remainder of the specified sequence starting from the position at which the specified result ended.</returns>
      <requires>result != null</requires>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Success``1(System.Int32)">
      <summary>
            Creates a new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified <paramref name="length" />
            and the default value for the specified <typeparamref name="TValue" /> type.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="length">The number of elements that were consumed in the sequence.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified 
            <paramref name="length" /> and a default value.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.SuccessMany``1(System.Int32)">
      <summary>
            Creates a new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified 
            <paramref name="length" /> and an empty sequence for the value.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="length">The number of elements that were consumed in the sequence.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified 
            <paramref name="length" /> and an empty sequence for the value.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;IEnumerable&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.ReturnSuccess``1(System.Int32)">
      <summary>
            Creates a singleton enumerable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> with 
            the specified <paramref name="length" /> and the default value for the specified 
            <typeparamref name="TValue" /> type.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="length">The number of elements that were consumed in the sequence.</param>
      <returns>A singleton enumerable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> with 
            the specified <paramref name="length" /> and a default value.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.ReturnSuccessMany``1(System.Int32)">
      <summary>
            Creates a singleton enumerable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> 
            with the specified <paramref name="length" /> and an empty sequence for the value.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="length">The number of elements that were consumed in the sequence.</param>
      <returns>A singleton enumerable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> 
            with the specified <paramref name="length" /> and an empty sequence for the value.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;IParseResult&lt;IEnumerable&lt;TValue&gt;&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.ReturnFailure``1">
      <summary>
            Creates an empty enumerable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <returns>An empty enumerable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.</returns>
      <ensures>Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.ReturnFailureMany``1">
      <summary>
            Creates an empty enumerable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <returns>An empty enumerable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.</returns>
      <ensures>Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Yield``1(Rxx.Parsers.IParseResult{``0})">
      <summary>
            Clones the specified <paramref name="result" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> from which to create a new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the same length and value as the 
            specified <paramref name="result" />.</returns>
      <requires>result != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Yield``1(Rxx.Parsers.IParseResult{``0},System.Int32)">
      <summary>
            Creates a new parse result with the specified <paramref name="length" /> 
            and the same value as the specified <paramref name="result" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> that provides the length.</param>
      <param name="length">The length of the new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified <paramref name="length" /> 
            and the same value as the specified <paramref name="result" />.</returns>
      <requires>result != null</requires>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Yield``2(Rxx.Parsers.IParseResult{``0},``1)">
      <summary>
            Creates a new parse result with the specified value and the length of the specified 
            <paramref name="result" />.
            </summary>
      <typeparam name="TOldValue">The type of the old parse result's value.</typeparam>
      <typeparam name="TNewValue">The type of the new parse result's value</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> that provides the length.</param>
      <param name="value">The value of the new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified value and the length of the specified 
            <paramref name="result" />.</returns>
      <requires>result != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TNewValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Yield``2(Rxx.Parsers.IParseResult{``0},System.Func{``0,``1})">
      <summary>
            Creates a new parse result with the value returned by the specified selector and the length of the 
            specified <paramref name="result" />.
            </summary>
      <typeparam name="TOldValue">The type of the old parse result's value.</typeparam>
      <typeparam name="TNewValue">The type of the new parse result's value</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> that provides the length.</param>
      <param name="valueSelector">A function that selects the value for the new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the value returned by the specified selector 
            and the length of the specified <paramref name="result" />.</returns>
      <requires>result != null</requires>
      <requires>valueSelector != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TNewValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Yield``3(Rxx.Parsers.IParseResult{``0},Rxx.Parsers.IParseResult{``1},System.Func{``0,``1,``2},System.Func{Rxx.Parsers.IParseResult{``0},Rxx.Parsers.IParseResult{``1},System.Int32})">
      <summary>
            Creates a new parse result from two parse results with the length and value returned 
            by the specified selectors.
            </summary>
      <typeparam name="TFirstValue">The type of the first parse result's value.</typeparam>
      <typeparam name="TSecondValue">The type of the second parse result's value.</typeparam>
      <typeparam name="TNewValue">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The first parse result.</param>
      <param name="secondResult">The second parse result.</param>
      <param name="valueSelector">A function that selects the value for the new parse result.</param>
      <param name="lengthSelector">A function that selects the length for the new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the length and value returned by the 
            specified selectors.</returns>
      <requires>firstResult != null</requires>
      <requires>secondResult != null</requires>
      <requires>valueSelector != null</requires>
      <requires>lengthSelector != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TNewValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Yield``3(Rxx.Parsers.IParseResult{``0},``1,System.Func{``0,``1,``2},System.Func{Rxx.Parsers.IParseResult{``0},``1,System.Int32})">
      <summary>
            Creates a new parse result from a parse result and another value with the length and value 
            returned by the specified selectors.
            </summary>
      <typeparam name="TValue">The type of the old parse result's value.</typeparam>
      <typeparam name="TOther">The type of the other value.</typeparam>
      <typeparam name="TNewValue">The type of the new parse result's value.</typeparam>
      <param name="result">The old parse result from which to create a new parse result.</param>
      <param name="other">The other value from which to create a new parse result.</param>
      <param name="valueSelector">A function that selects the value for the new parse result.</param>
      <param name="lengthSelector">A function that selects the length for the new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the length and value returned by the 
            specified selectors.</returns>
      <requires>result != null</requires>
      <requires>other != null</requires>
      <requires>valueSelector != null</requires>
      <requires>lengthSelector != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TNewValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.YieldMany``1(Rxx.Parsers.IParseResult{``0})">
      <summary>
            Creates a new parse result with the length of the specified <paramref name="result" />
            and a singleton enumerable sequence containing the value of the specified <paramref name="result" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> from which to create a new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the same length and value as the 
            specified <paramref name="result" />, although with the value wrapped in a singleton enumerable sequence.</returns>
      <requires>result != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;IEnumerable&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.YieldMany``1(Rxx.Parsers.IParseResult{``0},System.Int32)">
      <summary>
            Creates a new parse result with the specified <paramref name="length" /> and a singleton enumerable 
            sequence containing the value of the specified <paramref name="result" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> from which to create a new parse result.</param>
      <param name="length">The length of the new result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the same length and value as the 
            specified <paramref name="result" />, although with the value wrapped in a singleton enumerable sequence.</returns>
      <requires>result != null</requires>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;IEnumerable&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.ParserQueryContext`3">
      <summary>
            Represents a parser context over an enumerable sequence to support in-line grammars.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TQueryValue">The type of the current value in the query context.</typeparam>
      <invariant>parser != null</invariant>
    </member>
    <member name="T:Rxx.Parsers.ParserStart`2">
      <summary>
            Represents a parser that begins a parse operation at the beginning of the source sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <invariant>grammar != null</invariant>
    </member>
    <member name="T:Rxx.Parsers.Reactive.IObservableParser`2">
      <summary>
            Represents a parser over an observable sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})">
      <summary>
            Subscribes to the specified observable sequence and applies the parser's grammar, which is defined in 
            terms of the <see cref="P:Rxx.Parsers.Reactive.IObservableParser`2.Next" /> parser, to generate matches asynchronously.
            </summary>
      <param name="source">The observable sequence to parse.</param>
      <returns>An observable sequence of parse results that contain information about the matches.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IObservableParser`2.StartIndex">
      <summary>
            Gets the index into the sequence at which parsing begins.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IObservableParser`2.Next">
      <summary>
            Gets a parser with a grammar that matches the next element in the source sequence.
            </summary>
      <remarks>
            A parser's grammar is defined in terms of grammar rules, each of which is defined in terms of the <see cref="P:Rxx.Parsers.Reactive.IObservableParser`2.Next" /> parser
            or another rule.
            </remarks>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.Reactive.AmbiguousObservableParser`3">
      <summary>
            Represents an ambiguous parser that begins a parse operation at the current position of the source sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TUntilResult">The type of the elements that are generated by the optional until parser.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <invariant>parser != null</invariant>
      <invariant>untilCount &gt;= unlimitedCount</invariant>
    </member>
    <member name="T:Rxx.Parsers.Reactive.ObservableParser`2">
      <summary>
            Represents a parser over an observable sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <invariant>parser != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParser`2.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.Parser`2" /> class for derived classes.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParser`2.Parse(System.IObservable{`0})">
      <summary>
            Subscribes to the specified observable sequence and applies the parser's grammar, 
            which is defined by <see cref="P:Rxx.Parsers.Reactive.ObservableParser`2.Start" />, to generate matches.
            </summary>
      <param name="source">The oservable sequence to parse.</param>
      <returns>An observable sequence of parse results.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParser`2.StartIndex">
      <summary>
            Gets the index into the sequence at which parsing begins.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_StartIndex" inheritedFromTypeName="IObservableParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParser`2.Next">
      <summary>
            Gets a parser with a grammar that matches the next element in the source sequence.
            </summary>
      <remarks>
            A parser's grammar is defined in terms of grammar rules, each of which is defined in terms of the <see cref="P:Rxx.Parsers.Reactive.ObservableParser`2.Next" /> parser
            or another rule.
            </remarks>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParser`2.Start">
      <summary>
            Gets the parser's grammar as a parser that is defined in terms of the <see cref="P:Rxx.Parsers.Reactive.ObservableParser`2.Next" /> parser.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.Reactive.StringObservableParser`1">
      <summary>
            Represents a parser over an observable sequence of <see cref="T:System.Char" />.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of characters.</typeparam>
      <invariant>whiteSpace != null</invariant>
      <invariant>insignificantWhiteSpace != null</invariant>
    </member>
    <member name="T:Rxx.Parsers.Reactive.IStringObservableParser`1">
      <summary>
            Represents a parser over an observable sequence of <see cref="T:System.Char" />.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of characters.</typeparam>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop characters are parsed and joins them into a <see cref="T:System.String" />, excluding the stop character.
            </summary>
      <param name="stops">The characters at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop character is parsed
            or the sequence ends.</returns>
      <requires>stops != null</requires>
      <requires>stops.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed and joins them into a <see cref="T:System.String" />, excluding the stop word.
            </summary>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires>stopWords != null</requires>
      <requires>stopWords.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.StringComparer,System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed, using the specified <paramref name="comparer" />, and joins them into a <see cref="T:System.String" />, 
            excluding the stop word.
            </summary>
      <param name="comparer">An object that compares subsequences of parsed character strings to stop words.</param>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires>comparer != null</requires>
      <requires>stopWords != null</requires>
      <requires>stopWords.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters.
            </summary>
      <param name="value">The string of characters to match.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires>!string.IsNullOrEmpty(value)</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String,System.StringComparer)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters using the 
            specified <paramref name="comparer" />.
            </summary>
      <param name="value">The string of characters to match.</param>
      <param name="comparer">An object that compares subsequences of parsed character strings to the specified <paramref name="value" />.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires>!string.IsNullOrEmpty(value)</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Char)">
      <summary>
            Creates a parser with a grammar that matches the specified character.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> to match.</param>
      <returns>A parser with a grammar that matches the specified character.</returns>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Func{System.Char,System.Boolean})">
      <summary>
            Creates a parser with a grammar that matches when the specified <paramref name="predicate" />
            returns <see langword="true" /> for any given character.
            </summary>
      <param name="predicate">A function that receives each character and returns whether it will be consumed.</param>
      <returns>A parser with a grammar that matches each character for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires>predicate != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Globalization.UnicodeCategory)">
      <summary>
            Creates a parser with a grammar that matches each character within the specified 
            <paramref name="category" />.
            </summary>
      <param name="category">The unicode character in which to match characters.</param>
      <returns>A parser with a grammar that matches each character within the specified 
            <paramref name="category" />.</returns>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacter">
      <summary>
            Gets a parser with a grammar that matches any character.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IStringObservableParser`1.WhiteSpace">
      <summary>
            Gets a parser with a grammar that matches one or more consecutive whitespace characters according to the 
            rules of <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IStringObservableParser`1.InsignificantWhiteSpace">
      <summary>
            Gets a parser with a grammar that matches zero or more consecutive insignificant whitespace characters and joins
            them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.Reactive.StringObservableParser`1" /> class for derived classes.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.AnyCharacterUntil(System.Char[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop characters are parsed and joins them into a <see cref="T:System.String" />, excluding the stop character.
            </summary>
      <param name="stops">The characters at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop character is parsed
            or the sequence ends.</returns>
      <requires>stops != null</requires>
      <requires>stops.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.AnyCharacterUntil(System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed and joins them into a <see cref="T:System.String" />, excluding the stop word.
            </summary>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires>stopWords != null</requires>
      <requires>stopWords.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.AnyCharacterUntil(System.StringComparer,System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed, using the specified <paramref name="comparer" />, and joins them into a <see cref="T:System.String" />, 
            excluding the stop word.
            </summary>
      <param name="comparer">An object that compares subsequences of parsed character strings to stop words.</param>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires>comparer != null</requires>
      <requires>stopWords != null</requires>
      <requires>stopWords.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Word(System.String)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters.
            </summary>
      <param name="value">The string of characters to match.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires>!string.IsNullOrEmpty(value)</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Word(System.String,System.StringComparer)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters using the 
            specified <paramref name="comparer" />.
            </summary>
      <param name="value">The string of characters to match.</param>
      <param name="comparer">An object that compares subsequences of parsed character strings to the specified <paramref name="value" />.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires>!string.IsNullOrEmpty(value)</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Character(System.Char)">
      <summary>
            Creates a parser with a grammar that matches the specified character.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> to match.</param>
      <returns>A parser with a grammar that matches the specified character.</returns>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Character(System.Func{System.Char,System.Boolean})">
      <summary>
            Creates a parser with a grammar that matches when the specified <paramref name="predicate" />
            returns <see langword="true" /> for any given character.
            </summary>
      <param name="predicate">A function that receives each character and returns whether it will be consumed.</param>
      <returns>A parser with a grammar that matches each character for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires>predicate != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Character(System.Globalization.UnicodeCategory)">
      <summary>
            Creates a parser with a grammar that matches each character within the specified 
            <paramref name="category" />.
            </summary>
      <param name="category">The unicode character in which to match characters.</param>
      <returns>A parser with a grammar that matches each character within the specified 
            <paramref name="category" />.</returns>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.AnyCharacter">
      <summary>
            Gets a parser with a grammar that matches any character.
            </summary>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.WhiteSpace">
      <summary>
            Gets a parser with a grammar that matches one or more consecutive whitespace characters according to the 
            rules of <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.InsignificantWhiteSpace">
      <summary>
            Gets a parser with a grammar that matches zero or more consecutive whitespace characters determined by the 
            <see cref="P:Rxx.Parsers.Reactive.StringObservableParser`1.InsignificantWhiteSpaceCharacters" /> collection and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.InsignificantWhiteSpaceCharacters">
      <summary>
            Gets a collection of characters that are considered insignificant whitespace for the  
            <see cref="P:Rxx.Parsers.Reactive.StringObservableParser`1.InsignificantWhiteSpace" /> parser.  
            </summary>
      <getter>
        <ensures>Contract.Result&lt;ICollection&lt;char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions">
      <summary>
            Provides <see langword="static" /> methods for defining <see cref="T:Rxx.Parsers.Reactive.IObservableParser`2" /> grammars.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Aggregate``4(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}},System.Func{``2},System.Func{``2,``1,``2},System.Func{``2,``3})">
      <summary>
            Applies an <paramref name="accumulator" /> function over each result sequence from the 
            specified <paramref name="parser" /> and yields a sequence of accumulated results.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TAccumulate">The type of the accumulation.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from projecting the accumulation.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be aggregated.</param>
      <param name="seed">A function that returns the initial value of the accumulation for each parse result.</param>
      <param name="accumulator">A function to be invoked on each element of each parse result.</param>
      <param name="selector">A function that projects the final aggregation of each parse result.</param>
      <returns>A parser that returns the aggregated results.</returns>
      <requires>parser != null</requires>
      <requires>accumulator != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Join``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Appends each element in each result sequence from the specified <paramref name="parser" /> 
            to an accumulated <see cref="T:System.String" />, yielding a single <see cref="T:System.String" /> per result
            sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be joined into strings.</param>
      <returns>A parser that returns the aggregated <see cref="T:System.String" /> results.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Join``3(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}},System.Func{System.String,``2})">
      <summary>
            Appends each element in each result from the specified <paramref name="parser" /> 
            to an accumulated <see cref="T:System.String" /> and projects the strings for each result.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from projecting the accumulated <see cref="T:System.String" />.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be joined.</param>
      <param name="selector">A function that projects the aggregated <see cref="T:System.String" /> of each parse result.</param>
      <returns>A parser that returns the joined results.</returns>
      <requires>parser != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Join``4(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}},System.Func{``1,``2},System.Func{System.String,``3})">
      <summary>
            Applies a <paramref name="joiner" /> function over each result from the specified 
            <paramref name="parser" /> to create an accumulated <see cref="T:System.String" /> and projects 
            the strings for each result.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TJoin">The type of the accumulation on which <see cref="M:System.Object.ToString" /> is called.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from projecting the accumulated <see cref="T:System.String" />.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be joined.</param>
      <param name="joiner">A function to be invoked on each element of each parse result to produce a value 
            on which <see cref="M:System.Object.ToString" /> is called and appended to the accumulation.</param>
      <param name="selector">A function that projects the aggregated <see cref="T:System.String" /> of each parse result.</param>
      <returns>A parser that returns the joined results.</returns>
      <requires>parser != null</requires>
      <requires>joiner != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.NonGreedy``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Converts greedy matches from the specified <paramref name="parser" /> into matches that 
            have a length of zero.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The greedy parser to be made into a non-greedy parser.</param>
      <returns>A parser that converts the greedy matches from the specified <paramref name="parser" /> into 
            matches that have a length of zero.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Maybe``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> or yields success without a value when it does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that might produce matches.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> and 
            an empty observable sequence to indicate success when it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Maybe``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Matches the specified <paramref name="parser" /> or yields success without a value when it does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that might produce matches.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> and 
            an empty observable sequence to indicate success when it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Ambiguous``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Parses multiple sequences with the specified <paramref name="parser" />, starting from the beginning 
            of the source sequence and then skipping one element at a time, until there are no matches or the 
            source sequence ends.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The unambiguous parser that will parse each consecutive sequence until there are
            no matches or the source sequence ends.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> for each 
            consecutive sequence, starting from the beginning of the source sequence and then skipping one element 
            at a time, until there are no matches or the source sequence ends.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Ambiguous``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Int32)">
      <summary>
            Parses multiple sequences with the specified <paramref name="parser" />, starting from the beginning 
            of the source sequence and then skipping one element at a time, until the specified count is reached
            or the source sequence ends.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The unambiguous parser that will parse each consecutive sequence until the specified 
            count is reached or the source sequence ends.</param>
      <param name="untilCount">Indicates the maximum number of ambiguous matches to find.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> for each 
            consecutive sequence, starting from the beginning of the source sequence and then skipping one element 
            at a time, until the specified count is reached or the source sequence ends.</returns>
      <requires>parser != null</requires>
      <requires>untilCount &gt;= 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Ambiguous``3(Rxx.Parsers.Reactive.IObservableParser{``0,``2},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Parses multiple sequences with the specified <paramref name="parser" />, starting from the beginning 
            of the source sequence and then skipping one element at a time, until the other parser matches or the 
            source sequence ends.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TUntilResult">The type of the elements that are generated by the until parser.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The unambiguous parser that will parse each consecutive sequence until the other 
            parser matches or the source sequence ends.</param>
      <param name="untilParser">The parser that ends the ambiguity when it matches.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> for each 
            consecutive sequence, starting from the beginning of the source sequence and then skipping one element 
            at a time, until the other parser matches or the source sequence ends.</returns>
      <requires>parser != null</requires>
      <requires>untilParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Amplify``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into a singleton observable sequence
            that contains the match's value.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches will be projected into singleton observable sequences.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> projected into singleton
            observable sequences.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.One``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Matches the single element from the ambiguous result sequence in each match that is yielded by the specified 
            <paramref name="parser" /> and fails for any match in which there is zero or more than one element.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which the single result element is yielded for each match.</param>
      <returns>A parser that matches the single element from the result sequence of each match that is 
            yielded by the specified <paramref name="parser" /> and fails for any match in which there is zero 
            or more than one element.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Yield``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{System.IObservable{``0},System.IObservable{Rxx.Parsers.IParseResult{``2}}})">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" /> method 
            for the generated parser.</param>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Yield``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.String,System.Func{System.IObservable{``0},System.IObservable{Rxx.Parsers.IParseResult{``2}}})">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="name">The name of the parser that will appear in diagnostic trace output.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" /> method 
            for the generated parser.</param>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Yield``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{System.IObservable{``0},System.IObserver{Rxx.Parsers.IParseResult{``1}},System.IDisposable})">
      <summary>
            Creates a parser with the specified subscriber function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="parseSubscribe">A function that defines the behavior of the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" /> method 
            for the generated parser as an observable subscription.</param>
      <returns>A parser with the specified subscriber function.</returns>
      <requires>parser != null</requires>
      <requires>parseSubscribe != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Yield``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.String,System.Func{System.IObservable{``0},System.IObserver{Rxx.Parsers.IParseResult{``1}},System.IDisposable})">
      <summary>
            Creates a parser with the specified subscriber function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="name">The name of the parser that will appear in diagnostic trace output.</param>
      <param name="parseSubscribe">A function that defines the behavior of the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" /> method 
            for the generated parser as an observable subscription.</param>
      <returns>A parser with the specified subscriber function.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>parseSubscribe != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Yield``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{System.IObservable{``0},System.IObserver{Rxx.Parsers.IParseResult{``2}},System.IDisposable})">
      <summary>
            Creates a parser with the specified subscriber function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified subscriber function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="parseSubscribe">A function that defines the behavior of the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" /> method 
            for the generated parser as an observable subscription.</param>
      <returns>A parser with the specified subscriber function.</returns>
      <requires>parser != null</requires>
      <requires>parseSubscribe != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Yield``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.String,System.Func{System.IObservable{``0},System.IObserver{Rxx.Parsers.IParseResult{``2}},System.IDisposable})">
      <summary>
            Creates a parser with the specified subscriber function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified subscriber function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="name">The name of the parser that will appear in diagnostic trace output.</param>
      <param name="parseSubscribe">A function that defines the behavior of the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" /> method 
            for the generated parser as an observable subscription.</param>
      <returns>A parser with the specified subscriber function.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>parseSubscribe != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AsString``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Converts matches from the specified <paramref name="parser" /> into strings.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches will be converted into strings.</param>
      <returns>A parser that yields strings for the matches from the specified <paramref name="parser" />.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Cast``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Casts results from the specified <paramref name="parser" /> into the specified type.
            </summary>
      <remarks>
        <see cref="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Cast``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1})" /> is required for Windows Phone because it doesn't support covariance on 
            <see cref="T:System.IObservable`1" />, which is required for <see cref="T:Rxx.Parsers.Reactive.IObservableParser`2" /> to support covariance on 
            <strong>TResult</strong>.  A consequence is that parsers must sometimes be cast down to their base types before
            they can be combined using various parser operators.
            </remarks>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The original type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TCastResult">The type to which the elements that are generated from parsing the source elements are cast.</typeparam>
      <param name="parser">The parser from which results will be cast into the specified type.</param>
      <returns>A parser that casts results from the specified <paramref name="parser" />.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TCastResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Required``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> if the specified <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> if there are no matches.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Required``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.String)">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> with the specified message if the specified <paramref name="parser" /> 
            does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <param name="errorMessage">A <see cref="T:System.String" /> that describes the failed expectation to be used as the message 
            in the <see cref="T:Rxx.Parsers.ParseException" />.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> with the specified message if there are no matches.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(errorMessage)</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Required``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{System.String})">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> with a message returned by the specified function if the specified 
            <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <param name="errorMessageFactory">A function that returns a <see cref="T:System.String" /> describing the failed expectation 
            to be used as the message in the <see cref="T:Rxx.Parsers.ParseException" />.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> with a message returned by the specified functions if there are no matches.</returns>
      <requires>parser != null</requires>
      <requires>errorMessageFactory != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Required``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{System.Exception})">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> returned by the specified function if the specified 
            <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <param name="exceptionFactory">A function that returns the <see cref="T:Rxx.Parsers.ParseException" /> to be thrown describing the 
            failed expectation.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> returned by the specified functions if there are no matches.</returns>
      <requires>parser != null</requires>
      <requires>exceptionFactory != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Where``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,System.Boolean})">
      <summary>
            Matches all results from the specified <paramref name="parser" /> for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches will be filtered by the specified <paramref name="predicate" />.</param>
      <param name="predicate">A function that returns <see langword="true" /> to indicate when a match should be yielded and 
            <see langword="false" /> when a match should be ignored.</param>
      <returns>A parser that matches only those results from the specified <paramref name="parser" /> for which 
            the specified <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires>parser != null</requires>
      <requires>predicate != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.IgnoreBefore``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,``2})">
      <summary>
            Matches the left parser followed by the right parser, but only returns the right parser's matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIgnore">The type of the elements that are generated by the left parser.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated by the right parser.</typeparam>
      <param name="ignoreParser">The parser from which to ignore matches.</param>
      <param name="parser">The parser from which to yield matches.</param>
      <returns>A parser that matches the left parser followed by the right parser, but only returns the 
            right parser's matches.</returns>
      <requires>ignoreParser != null</requires>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.IgnoreTrailing``3(Rxx.Parsers.Reactive.IObservableParser{``0,``2},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the left parser followed by the right parser, but only returns the left parser's matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIgnore">The type of the elements that are generated by the right parser.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated by the left parser.</typeparam>
      <param name="parser">The parser from which to yield matches.</param>
      <param name="ignoreParser">The parser from which to ignore matches.</param>
      <returns>A parser that matches the left parser followed by the right parser, but only returns the 
            left parser's matches.</returns>
      <requires>parser != null</requires>
      <requires>ignoreParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Of``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},``1)">
      <summary>
            Matches all results from the specified <paramref name="parser" /> that equal the specified
            <paramref name="value" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches equivalent to the specified <paramref name="value" /> will be yielded.</param>
      <param name="value">The value to be compared to matches for equality.</param>
      <returns>A parser that matches only those results from the specified <paramref name="parser" /> that equal
            the specified <paramref name="value" />.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Of``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},``1,System.Collections.Generic.IEqualityComparer{``1})">
      <summary>
            Matches all results from the specified <paramref name="parser" /> that equal the specified
            <paramref name="value" /> using the specified <paramref name="comparer" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches equivalent to the specified <paramref name="value" /> will be yielded.</param>
      <param name="value">The value to be compared to matches for equality.</param>
      <param name="comparer">The object that compares matches to the specified <paramref name="value" /> for equality.</param>
      <returns>A parser that matches only those results from the specified <paramref name="parser" /> that equal
            the specified <paramref name="value" /> using the specified <paramref name="comparer" />.</returns>
      <requires>parser != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Group``4(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,``3},Rxx.Parsers.Reactive.IObservableParser{``0,``2})">
      <summary>
            Matches the <paramref name="content" /> between the specified <paramref name="open" /> and <paramref name="close" /> parsers.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TOpen">The type of the elements that are generated from parsing the <paramref name="open" /> elements.</typeparam>
      <typeparam name="TClose">The type of the elements that are generated from parsing the <paramref name="close" /> elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the <paramref name="content" /> elements.</typeparam>
      <param name="open">The parser after which the matching of <paramref name="content" /> begins.</param>
      <param name="content">The parser that matches values between the <paramref name="open" /> and <paramref name="close" /> parsers.</param>
      <param name="close">The parser at which the matching of <paramref name="content" /> ends.</param>
      <returns>A parser with a grammar that matches the <paramref name="open" /> parser, followed by the <paramref name="content" /> parser
            and finally the <paramref name="close" /> parser, yielding the results of the <paramref name="content" /> parser only.</returns>
      <requires>open != null</requires>
      <requires>content != null</requires>
      <requires>close != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Group``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,``2})">
      <summary>
            Matches zero or more values in between the specified <paramref name="open" /> and <paramref name="close" /> parsers.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TOpen">The type of the elements that are generated from parsing the <paramref name="open" /> elements.</typeparam>
      <typeparam name="TClose">The type of the elements that are generated from parsing the <paramref name="close" /> elements.</typeparam>
      <param name="open">The parser after which the group begins.</param>
      <param name="close">The parser at which the group ends.</param>
      <returns>A parser with a grammar that matches the <paramref name="open" /> parser, followed by everything up to the first 
            match of the <paramref name="close" /> parser, yielding the results in between.</returns>
      <requires>open != null</requires>
      <requires>close != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AmbiguousGroup``1(Rxx.Parsers.Reactive.IObservableParser{``0,``0},Rxx.Parsers.Reactive.IObservableParser{``0,``0})">
      <summary>
            Matches everything in between the specified <paramref name="open" /> and <paramref name="close" /> parsers, 
            yielding the first unambiguous match as well as everything in between any sub-groups and overlapping groups, 
            extending past the unambiguous match of the <paramref name="close" /> parser, that match the same grammar.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <param name="open">The parser after which the group begins.</param>
      <param name="close">The parser at which the group ends.</param>
      <remarks>
            The same <paramref name="open" /> or <paramref name="close" /> parser may produce multiple matches at the same index.
            </remarks>
      <returns>A parser with a grammar that matches the <paramref name="open" /> parser, followed by everything up to the first 
            match of the <paramref name="close" /> parser, yielding the results in between as well as the results of all ambiguous 
            matches of the group grammar.</returns>
      <requires>open != null</requires>
      <requires>close != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Not``3(Rxx.Parsers.Reactive.IObservableParser{``0,``2},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> when the specified <paramref name="notParser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TNotResult">The type of the elements that are generated by the <paramref name="notParser" />.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match when the specified <paramref name="notParser" /> does not match.</param>
      <param name="notParser">The parser that when it matches will cause the matches from the specified 
            <paramref name="parser" /> to be ignored.</param>
      <returns>A parser that matches the specified <paramref name="parser" /> when the specified <paramref name="notParser" />
            does not match.</returns>
      <requires>parser != null</requires>
      <requires>notParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Or``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches either the left parser or the right parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that has precedence.</param>
      <param name="nextParser">The parser that is matched if the first <paramref name="parser" /> does not match.</param>
      <returns>A parser that yields the matches from <paramref name="parser" /> if there are any; otherwise, the matches 
            from <paramref name="nextParser" /> are yielded.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Any``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{``0,``1}})">
      <summary>
            Matches the first parser that is successful.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched until one is successful.</param>
      <returns>A parser that yields the matches from the first parser in <paramref name="parsers" /> that is successful.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Any``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1}[])">
      <summary>
            Matches the first parser that is successful.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched until one is successful.</param>
      <returns>A parser that yields the matches from the first parser in <paramref name="parsers" /> that is successful.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.And``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.And``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.And``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.And``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}},Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.All``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{``0,``1}})">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.All``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1}[])">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.All``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}}})">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.All``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}}[])">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Parse``2(System.Func{Rxx.Parsers.Reactive.IObservableParser{``0,``0},Rxx.Parsers.Reactive.IObservableParser{``0,``1}})">
      <summary>
            Creates a parser from the specified <paramref name="grammar" /> function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="grammar">A function the accepts a parser that acts as a cursor and returns a parser that matches 
            in terms of the cursor.</param>
      <returns>A parser that yields matches from the specified <paramref name="grammar" />.</returns>
      <requires>grammar != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Parse``2(System.IObservable{``0},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Applies the specified <paramref name="parser" /> to generate matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The observable sequence to parse.</param>
      <param name="parser">An object that defines a grammar to be applied to the observable sequence to generate matches.</param>
      <returns>An observable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Parse``2(System.IObservable{``0},System.Func{Rxx.Parsers.Reactive.ObservableParserQueryContext{``0,``0,Rxx.Parsers.Reactive.IObservableParser{``0,``0}},Rxx.Parsers.Reactive.ObservableParserQueryContext{``0,``0,Rxx.Parsers.Reactive.IObservableParser{``0,``1}}})">
      <summary>
            Applies the specified unambiguous parser grammar to generate matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The observable sequence to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.Parse(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor
            	let letter = next.Where(char.IsLetter)
            	let number = next.Where(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An observable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Parse``2(System.IObservable{``0},System.Func{Rxx.Parsers.Reactive.ObservableParserQueryContext{``0,``0,Rxx.Parsers.Reactive.IObservableParser{``0,``0}},Rxx.Parsers.Reactive.ObservableParserQueryContext{``0,``0,Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}}}})">
      <summary>
            Applies the specified ambiguous parser grammar to generate matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The observable sequence to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.Parse(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor
            	let letter = next.Where(char.IsLetter)
            	let number = next.Where(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An observable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.ParseString``1(System.IObservable{System.Char},System.Func{Rxx.Parsers.Reactive.StringObservableParserQueryContext{System.Char,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Char}},Rxx.Parsers.Reactive.StringObservableParserQueryContext{System.Char,Rxx.Parsers.Reactive.IObservableParser{System.Char,``0}}})">
      <summary>
            Applies the specified unambiguous parser grammar to generate matches from a sequence of characters.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source characters.</typeparam>
      <param name="source">The observable sequence of <see cref="T:System.Char" /> to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.ParseString(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor or specialized parser functions
            	// that use the cursor
            	let letter = parser.Character(char.IsLetter)
            	let number = parser.Character(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An observable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.ParseString``1(System.IObservable{System.Char},System.Func{Rxx.Parsers.Reactive.StringObservableParserQueryContext{System.Char,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Char}},Rxx.Parsers.Reactive.StringObservableParserQueryContext{System.Char,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{``0}}}})">
      <summary>
            Applies the specified ambiguous parser grammar to generate matches from a sequence of characters.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source characters.</typeparam>
      <param name="source">The sequence of <see cref="T:System.Char" /> to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.ParseString(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor or specialized parser functions
            	// that use the cursor
            	let letter = parser.Character(char.IsLetter)
            	let number = parser.Character(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An observable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Select``4(Rxx.Parsers.Reactive.ObservableParserQueryContext{``0,``1,``2},System.Func{``2,``3})">
      <summary>
            Enables defining in-line parser grammars using LINQ.
            </summary>
      <typeparam name="TParseSource">The type of the original source elements.</typeparam>
      <typeparam name="TParseResult">The type of the elements that are originally generated from parsing the source elements.</typeparam>
      <typeparam name="TSource">The type of the source elements; typically, this will be an anonymous compiler-generaed type.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The parser query context to be projected.</param>
      <param name="selector">A function that projects the current result of the query context.</param>
      <returns>A new query context that is the projection of the specified query context using the specified <paramref name="selector" />.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ObservableParserQueryContext&lt;TParseSource, TParseResult, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Select``3(Rxx.Parsers.Reactive.StringObservableParserQueryContext{``0,``1},System.Func{``1,``2})">
      <summary>
            Enables defining in-line parser grammars using LINQ.
            </summary>
      <typeparam name="TParseResult">The type of the elements that are originally generated from parsing the source elements.</typeparam>
      <typeparam name="TSource">The type of the source elements; typically, this will be an anonymous compiler-generaed type.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The parser query context to be projected.</param>
      <param name="selector">A function that projects the current result of the query context.</param>
      <returns>A new query context that is the projection of the specified query context using the specified <paramref name="selector" />.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;StringObservableParserQueryContext&lt;TParseResult, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Select``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,``2})">
      <summary>
            Projects matches from the specified <paramref name="parser" /> into a new form.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the matches of the specified <paramref name="parser" />.</typeparam>
      <param name="parser">The parser from which matches will be projected by the specified <paramref name="selector" /> function.</param>
      <param name="selector">A transform function to apply to each match.</param>
      <returns>A parser that projects matches from the specified <paramref name="parser" /> into a new form.</returns>
      <requires>parser != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.SelectMany``4(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,Rxx.Parsers.Reactive.IObservableParser{``0,``2}},System.Func{``1,``2,``3})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into another parser, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TSecondResult">The type of the elements that are generated from the projected parsers.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the matches of the projected parsers.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified parser selector function to create 
            the next parser.</param>
      <param name="parserSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each match from the projected parsers.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into another parser, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>parserSelector != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.SelectMany``4(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,Rxx.Parsers.Reactive.IObservableParser{``0,``2}},System.Func{``1,``2,``3},System.Func{Rxx.Parsers.IParseResult{``1},Rxx.Parsers.IParseResult{``2},System.Int32})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into another parser, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TSecondResult">The type of the elements that are generated from the projected parsers.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the matches of the projected parsers.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified parser selector function to create 
            the next parser.</param>
      <param name="parserSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each match from the projected parsers.</param>
      <param name="lengthSelector">A function that returns the length for each pair of projected matches.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into another parser, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>parserSelector != null</requires>
      <requires>resultSelector != null</requires>
      <requires>lengthSelector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.SelectMany``4(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,System.IObservable{``2}},System.Func{``1,``2,``3})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into an observable sequence, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TCollection">The type of the elements in the sequences that are projected from the matches.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the projected sequences.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified collection selector function.</param>
      <param name="collectionSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each element from the projected sequences.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into an observable sequence, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>collectionSelector != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.SelectMany``4(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,System.IObservable{``2}},System.Func{``1,``2,``3},System.Func{Rxx.Parsers.IParseResult{``1},``2,System.Int32})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into an observable sequence, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TCollection">The type of the elements in the sequences that are projected from the matches.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the projected sequences.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified collection selector function.</param>
      <param name="collectionSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each element from the projected sequences.</param>
      <param name="lengthSelector">A function that returns the length for each pair of projected values.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into an observable sequence, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>collectionSelector != null</requires>
      <requires>resultSelector != null</requires>
      <requires>lengthSelector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Single``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches only a single match from the specified <paramref name="parser" /> 
            and fails if there is zero or more than one match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which only a single match is expected.</param>
      <returns>A parser that matches only a single match from the specified <paramref name="parser" /> 
            and fails if there is zero or more than one match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AtLeast``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Int32)">
      <summary>
            Matches the specified <paramref name="parser" /> consecutively a minimum number of times.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched consecutively a minimum number of times.</param>
      <param name="count">The number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <returns>A parser that consecutively matches the specified <paramref name="parser" /> the minimum 
            number of times specified by <paramref name="count" />.</returns>
      <requires>parser != null</requires>
      <requires>count &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.None``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},``1)">
      <summary>
            Yields success when the specified <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which any match results in failure.</param>
      <param name="successResult">The value that is yielded if the specified <paramref name="parser" /> does not match.</param>
      <returns>A parser that yields failure when the specified <paramref name="parser" /> matches or success when 
            it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.None``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Yields success when the specified <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which any match results in failure.</param>
      <returns>A parser that yields failure when the specified <paramref name="parser" /> matches or 
            an empty sequence to indicate success when it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.None``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Yields success when the specified <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated 
            from parsing the source elements.</typeparam>
      <param name="parser">The parser for which any match results in failure.</param>
      <returns>A parser that yields failure when the specified <paramref name="parser" /> matches or 
            an empty sequence to indicate success when it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.WithDefault``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},``1)">
      <summary>
            Matches the specified <paramref name="parser" /> or yields the specified default result if there are 
            no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that might produce matches.</param>
      <param name="defaultResult">The value that is yielded if the specified <paramref name="parser" /> does not match.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> or the specified default result
            if the <paramref name="parser" /> does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.NoneOrMore``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> zero or more times consecutively.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match zero or more times consecutively.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> zero or more times consecutively.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.NoneOrMore``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> zero or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match zero or more times consecutively.</param>
      <param name="separator">The parser that matches between consecutive matches of the specified <paramref name="parser" />.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> zero or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.</returns>
      <requires>parser != null</requires>
      <requires>separator != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.OneOrMore``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> one or more times consecutively.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match one or more times consecutively.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> one or more times consecutively.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.OneOrMore``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> one or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match one or more times consecutively.</param>
      <param name="separator">The parser that matches between consecutive matches of the specified <paramref name="parser" />.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> one or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.</returns>
      <requires>parser != null</requires>
      <requires>separator != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.OnSuccess``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Action{Rxx.Parsers.IParseResult{``1}})">
      <summary>
            Invokes the specified <paramref name="action" /> on each result for its side-effects.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which results will be supplied to the specified <paramref name="action" />.</param>
      <param name="action">The method that will be called for each parser result.</param>
      <returns>A new parser that is the same as the specified parser and also inovkes the specified 
            <paramref name="action" /> with each result for its side-effects.</returns>
      <requires>parser != null</requires>
      <requires>action != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.OnFailure``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Action)">
      <summary>
            Invokes the specified <paramref name="action" /> for its side-effects if the specified <paramref name="parser" />
            does not yield any results.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which no results will cause the specified <paramref name="action" /> to be invoked.</param>
      <param name="action">Invoked if the <paramref name="parser" /> does not yield any results.</param>
      <returns>A new parser that is the same as the specified parser and also inovkes the specified 
            <paramref name="action" /> for its side-effects if the specified <paramref name="parser" /> does not yield
            any results.</returns>
      <requires>parser != null</requires>
      <requires>action != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Defer``2(System.Func{Rxx.Parsers.Reactive.IObservableParser{``0,``1}})">
      <summary>
            Defers creation of a parser until the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" /> method is called.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parserFactory">A function that returns the underlying <see cref="T:Rxx.Parsers.Reactive.IObservableParser`2" /> on which 
            the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" /> method will be called.</param>
      <returns>A parser that defers creation of its underlying parser until the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" /> 
            method is called.</returns>
      <requires>parserFactory != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Success``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},``2)">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding the specified scalar <paramref name="result" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the <paramref name="result" />.</typeparam>
      <param name="parser">The parser for which the specified <paramref name="result" /> indicates success.</param>
      <param name="result">The value of the created parser's result.</param>
      <returns>A parser that always returns the specified scalar <paramref name="result" /> with a length 
            of zero, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Success``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},``2,System.Int32)">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding the specified scalar <paramref name="result" /> 
            with the specified length.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the <paramref name="result" />.</typeparam>
      <param name="parser">The parser for which the specified <paramref name="result" /> indicates success.</param>
      <param name="result">The value of the created parser's result.</param>
      <param name="length">The length of the created parser's result.</param>
      <returns>A parser that always returns the specified scalar <paramref name="result" /> with the specified 
            length, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Success``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding a single result containing an empty sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which a single empty result sequence is returned to indicate success.</param>
      <returns>A parser that returns a single result containing an empty sequence with a length 
            of zero, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Success``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding a single result containing an empty sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements in the sequences that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which a single empty result sequence is returned to indicate success.</param>
      <remarks>
        <see cref="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Success``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})" /> is required as an explicit overload
            because the meaning of the parser's result sequence is special and must not be compounded into a sequence of sequences, 
            which would happen if the <see cref="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Success``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})" /> overload were to be called
            instead.
            </remarks>
      <returns>A parser that returns a single result containing an empty sequence with a length 
            of zero, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Failure``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Indicates a failure to parse without actually parsing by returning an empty sequence of parse results.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that is to fail.</param>
      <returns>A parser that always returns an empty sequence of parse results, starting from the index at which 
            the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.ObservableParseResult">
      <summary>
            Provides <see langword="static" /> methods for creating <see cref="T:Rxx.Parsers.ParseResult`1" /> objects.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.Concat``1(Rxx.Parsers.IParseResult{System.IObservable{``0}},Rxx.Parsers.IParseResult{``0})">
      <summary>
            Concatenates the specified parse result value sequence and scalar parse result value into a new parse result value sequence.
            The lengths are summed to indicate that the new parse result 
            encompesses both of the specified parse results and that they match consecutively
            in the input sequence.
            </summary>
      <typeparam name="TResult">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The parse result value sequence to which <paramref name="secondResult" /> will be concatenated.</param>
      <param name="secondResult">The scalar parse result value to be concatenated to the value of <paramref name="firstResult" />.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> object containing the sum of the specified parse results' lengths and 
            the concatenation of their values.</returns>
      <requires>firstResult != null</requires>
      <requires>firstResult.Value != null</requires>
      <requires>secondResult != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.Concat``1(Rxx.Parsers.IParseResult{``0},Rxx.Parsers.IParseResult{System.IObservable{``0}})">
      <summary>
            Concatenates the specified scalar parse result value and parse result value sequence into a new parse result value sequence.
            The lengths are summed to indicate that the new parse result 
            encompesses both of the specified parse results and that they match consecutively
            in the input sequence.
            </summary>
      <typeparam name="TResult">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The scalar parse result value to which <paramref name="secondResult" /> will be concatenated.</param>
      <param name="secondResult">The parse result value sequence to be concatenated to the value of <paramref name="firstResult" />.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> object containing the sum of the specified parse results' 
            lengths and the concatenation of their values.</returns>
      <requires>firstResult != null</requires>
      <requires>secondResult != null</requires>
      <requires>secondResult.Value != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.Concat``1(Rxx.Parsers.IParseResult{System.IObservable{``0}},Rxx.Parsers.IParseResult{System.IObservable{``0}})">
      <summary>
            Concatenates the specified parse result value sequences into a new parse result value sequence.
            The lengths are summed to indicate that the new parse result 
            encompesses both of the specified parse results and that they match consecutively
            in the input sequence.
            </summary>
      <typeparam name="TResult">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The parse result value sequence to which <paramref name="secondResult" /> will be concatenated.</param>
      <param name="secondResult">The parse result value sequence to be concatenated to the value sequence of <paramref name="firstResult" />.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> object containing the sum of the specified parse results' 
            lengths and the concatenation of their values.</returns>
      <requires>firstResult != null</requires>
      <requires>firstResult.Value != null</requires>
      <requires>secondResult != null</requires>
      <requires>secondResult.Value != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.Return``1(``0,System.Int32)">
      <summary>
            Creates a singleton observable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" />  
            with the specified <paramref name="value" /> and <paramref name="length" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="value">The projection of elements of a parse operation.</param>
      <param name="length">The number of elements that were consumed in the sequence to generate 
            the specified <paramref name="value" />.</param>
      <returns>A singleton observable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" />  
            with the specified <paramref name="value" /> and <paramref name="length" />.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.Remainder``2(Rxx.Parsers.IParseResult{``1},System.IObservable{``0})">
      <summary>
            Returns the remainder of the specified sequence starting from the <see cref="P:Rxx.Parsers.IParseResult`1.Length" /> 
            of the specified <paramref name="result" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> that indicates at which point the remainder of the sequence begins.</param>
      <param name="source">The sequence for which a remainder will be returned.</param>
      <returns>The remainder of the specified sequence starting from the position at which the specified result ended.</returns>
      <requires>result != null</requires>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.SuccessMany``1(System.Int32)">
      <summary>
            Creates a new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified 
            <paramref name="length" /> and an empty sequence for the value.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="length">The number of elements that were consumed in the sequence.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified 
            <paramref name="length" /> and an empty sequence for the value.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;IObservable&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.ReturnSuccess``1(System.Int32)">
      <summary>
            Creates a singleton observable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> with 
            the specified <paramref name="length" /> and the default value for the specified 
            <typeparamref name="TValue" /> type.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="length">The number of elements that were consumed in the sequence.</param>
      <returns>A singleton observable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> with 
            the specified <paramref name="length" /> and a default value.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.ReturnSuccessMany``1(System.Int32)">
      <summary>
            Creates a singleton observable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> 
            with the specified <paramref name="length" /> and an empty sequence for the value.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="length">The number of elements that were consumed in the sequence.</param>
      <returns>A singleton observable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> 
            with the specified <paramref name="length" /> and an empty sequence for the value.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;IObservable&lt;TValue&gt;&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.ReturnFailure``1">
      <summary>
            Creates an empty observable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <returns>An empty observable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.</returns>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.ReturnFailureMany``1">
      <summary>
            Creates an empty observable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <returns>An empty observable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.</returns>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.YieldMany``1(Rxx.Parsers.IParseResult{``0})">
      <summary>
            Creates a new parse result with the length of the specified <paramref name="result" />
            and a singleton observable sequence containing the value of the specified <paramref name="result" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> from which to create a new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the same length and value as the 
            specified <paramref name="result" />, although with the value wrapped in a singleton observable sequence.</returns>
      <requires>result != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;IObservable&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.YieldMany``1(Rxx.Parsers.IParseResult{``0},System.Int32)">
      <summary>
            Creates a new parse result with the specified <paramref name="length" /> and a singleton observable 
            sequence containing the value of the specified <paramref name="result" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> from which to create a new parse result.</param>
      <param name="length">The length of the new result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the same length and value as the 
            specified <paramref name="result" />, although with the value wrapped in a singleton observable sequence.</returns>
      <requires>result != null</requires>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;IObservable&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.ObservableParserQueryContext`3">
      <summary>
            Represents a parser context over an observable sequence to support in-line grammars.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TQueryValue">The type of the current value in the query context.</typeparam>
      <invariant>parser != null</invariant>
    </member>
    <member name="T:Rxx.Parsers.Reactive.ObservableParserStart`2">
      <summary>
            Represents a parser that begins a parse operation at the beginning of the source sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <invariant>grammar != null</invariant>
    </member>
    <member name="F:Rxx.Parsers.Reactive.ParserSubject`1.getStartIndex">
      <summary>
            Some parsers, such as AnyParser, will throw when reading the StartIndex property unless Parse has 
            been called.  This function allows the start index to be lazily retrieved from the wrapping parser
            so that it doesn't have to be read when the cursor is being constructed.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ParserSubject`1.Move(System.Int32)">
      <summary>
            Changes the start element of the cursor to the element at the specified number of elements forward.
            </summary>
      <param name="count">The number of elements after the current element at which the start will be positioned.</param>
      <remarks>
            In addition to advancing the start position, this method also frees memory held by elements that are no longer needed.
            </remarks>
      <requires>count &gt;= 0</requires>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ParserSubject`1.MoveToCurrent">
      <summary>
            Changes the start element of the cursor to the element after the last element that was read.
            </summary>
      <remarks>
            In addition to advancing the start position, this method also frees memory held by elements that are no longer needed.
            </remarks>
      <returns>The number of elements that the cursor moved to reach the current position.</returns>
      <ensures>Contract.Result&lt;int&gt;() &gt;= 0</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2">
      <summary>
            Represents a parser context over an enumerable sequence of <see cref="T:System.Char" />
            to support in-line grammars.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of characters.</typeparam>
      <typeparam name="TQueryValue">The type of the current value in the query context.</typeparam>
      <invariant>parser != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.AnyCharacterUntil(System.Char[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop characters are parsed and joins them into a <see cref="T:System.String" />, excluding the stop character.
            </summary>
      <param name="stops">The characters at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop character is parsed
            or the sequence ends.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">stops != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">stops.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.AnyCharacterUntil(System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed and joins them into a <see cref="T:System.String" />, excluding the stop word.
            </summary>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.AnyCharacterUntil(System.StringComparer,System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed, using the specified <paramref name="comparer" />, and joins them into a <see cref="T:System.String" />, 
            excluding the stop word.
            </summary>
      <param name="comparer">An object that compares subsequences of parsed character strings to stop words.</param>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringObservableParser">comparer != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Word(System.String)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters.
            </summary>
      <param name="value">The string of characters to match.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String)" inheritedFromTypeName="IStringObservableParser">!string.IsNullOrEmpty(value)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Word(System.String,System.StringComparer)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters using the 
            specified <paramref name="comparer" />.
            </summary>
      <param name="value">The string of characters to match.</param>
      <param name="comparer">An object that compares subsequences of parsed character strings to the specified <paramref name="value" />.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String,System.StringComparer)" inheritedFromTypeName="IStringObservableParser">!string.IsNullOrEmpty(value)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String,System.StringComparer)" inheritedFromTypeName="IStringObservableParser">comparer != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String,System.StringComparer)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Character(System.Char)">
      <summary>
            Creates a parser with a grammar that matches the specified character.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> to match.</param>
      <returns>A parser with a grammar that matches the specified character.</returns>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Char)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Character(System.Func{System.Char,System.Boolean})">
      <summary>
            Creates a parser with a grammar that matches when the specified <paramref name="predicate" />
            returns <see langword="true" /> for any given character.
            </summary>
      <param name="predicate">A function that receives each character and returns whether it will be consumed.</param>
      <returns>A parser with a grammar that matches each character for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringObservableParser">predicate != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Character(System.Globalization.UnicodeCategory)">
      <summary>
            Creates a parser with a grammar that matches each character within the specified 
            <paramref name="category" />.
            </summary>
      <param name="category">The unicode character in which to match characters.</param>
      <returns>A parser with a grammar that matches each character within the specified 
            <paramref name="category" />.</returns>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Globalization.UnicodeCategory)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.AnyCharacter">
      <summary>
            Gets a parser with a grammar that matches any character.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_AnyCharacter" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.WhiteSpace">
      <summary>
            Gets a parser with a grammar that matches one or more consecutive whitespace characters according to the 
            rules of <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_WhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.InsignificantWhiteSpace">
      <summary>
            Gets a parser with a grammar that matches zero or more consecutive insignificant whitespace characters and joins
            them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.StringParserDefaults">
      <summary>
            Provides default values for <see cref="T:Rxx.Parsers.StringParser`1" />.
            </summary>
    </member>
    <member name="F:Rxx.Parsers.StringParserDefaults.InsignificantWhiteSpaceCharacters">
      <summary>
            The default collection of whitespace characters returned by <see cref="P:Rxx.Parsers.StringParser`1.InsignificantWhiteSpaceCharacters" />.
            The collection contains a space, tab, new-line, and carriage return.
            </summary>
    </member>
    <member name="T:Rxx.Parsers.StringParserQueryContext`2">
      <summary>
            Represents a parser context over a <see cref="T:System.String" /> or an enumerable sequence of <see cref="T:System.Char" />
            to support in-line grammars.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of characters.</typeparam>
      <typeparam name="TQueryValue">The type of the current value in the query context.</typeparam>
      <invariant>parser != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.AnyCharacterUntil(System.Char[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop characters are parsed and joins them into a <see cref="T:System.String" />, excluding the stop character.
            </summary>
      <param name="stops">The characters at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop character is parsed
            or the sequence ends.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">stops != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">stops.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.AnyCharacterUntil(System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed and joins them into a <see cref="T:System.String" />, excluding the stop word.
            </summary>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.AnyCharacterUntil(System.StringComparer,System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed, using the specified <paramref name="comparer" />, and joins them into a <see cref="T:System.String" />, 
            excluding the stop word.
            </summary>
      <param name="comparer">An object that compares subsequences of parsed character strings to stop words.</param>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringParser">comparer != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.Word(System.String)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters.
            </summary>
      <param name="value">The string of characters to match.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String)" inheritedFromTypeName="IStringParser">!string.IsNullOrEmpty(value)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.Word(System.String,System.StringComparer)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters using the 
            specified <paramref name="comparer" />.
            </summary>
      <param name="value">The string of characters to match.</param>
      <param name="comparer">An object that compares subsequences of parsed character strings to the specified <paramref name="value" />.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String,System.StringComparer)" inheritedFromTypeName="IStringParser">!string.IsNullOrEmpty(value)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String,System.StringComparer)" inheritedFromTypeName="IStringParser">comparer != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String,System.StringComparer)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.Character(System.Char)">
      <summary>
            Creates a parser with a grammar that matches the specified character.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> to match.</param>
      <returns>A parser with a grammar that matches the specified character.</returns>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Char)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.Character(System.Func{System.Char,System.Boolean})">
      <summary>
            Creates a parser with a grammar that matches when the specified <paramref name="predicate" />
            returns <see langword="true" /> for any given character.
            </summary>
      <param name="predicate">A function that receives each character and returns whether it will be consumed.</param>
      <returns>A parser with a grammar that matches each character for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringParser">predicate != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.Character(System.Globalization.UnicodeCategory)">
      <summary>
            Creates a parser with a grammar that matches each character within the specified 
            <paramref name="category" />.
            </summary>
      <param name="category">The unicode character in which to match characters.</param>
      <returns>A parser with a grammar that matches each character within the specified 
            <paramref name="category" />.</returns>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Globalization.UnicodeCategory)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.StringParserQueryContext`2.AnyCharacter">
      <summary>
            Gets a parser with a grammar that matches any character.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_AnyCharacter" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.StringParserQueryContext`2.WhiteSpace">
      <summary>
            Gets a parser with a grammar that matches one or more consecutive whitespace characters according to the 
            rules of <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_WhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.StringParserQueryContext`2.InsignificantWhiteSpace">
      <summary>
            Gets a parser with a grammar that matches zero or more consecutive insignificant whitespace characters and joins
            them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.XmlParser">
      <summary>
            Represents a context-free XML parser over a <see cref="T:System.String" /> or an enumerable sequence of <see cref="T:System.Char" />.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.XmlParser.#ctor(System.Boolean)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.XmlParser" /> class with the specified case-sensitivity.
            </summary>
      <param name="caseSensitive">Indicates whether the comparison behavior used for matching element and attribute names
            must ignore case.</param>
    </member>
    <member name="M:Rxx.Parsers.XmlParser.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.XmlParser" /> class.
            </summary>
    </member>
    <member name="P:Rxx.Parsers.XmlParser.Schema">
      <summary>
            Gets the parser's grammar.  The default grammar matches an XML element with any attributes or content.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.XmlParser`1.get_Schema" inheritedFromTypeName="XmlParser">Contract.Result&lt;IParser&lt;char, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.XmlParserQueryContext`2">
      <summary>
            Represents an XML parser context over a <see cref="T:System.String" /> or an enumerable sequence of <see cref="T:System.Char" />
            to support in-line grammars.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of XML nodes.</typeparam>
      <typeparam name="TQueryValue">The type of the current value in the query context.</typeparam>
      <invariant>parser != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Attribute(System.String)">
      <summary>
            Creates a parser that matches a single XML attribute with the specified <paramref name="name" />.
            </summary>
      <param name="name">The name of the attribute to match.</param>
      <returns>A parser that matches a single XML attribute with the specified <paramref name="name" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified children.
            </summary>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified children.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified attributes and children.
            </summary>
      <remarks>
            IParser is not covariant on TResult in Silverlight because <see cref="T:System.Collections.Generic.IEnumerable`1" /> is not covariant on T.
            For this reason, the <paramref name="content" /> parameter cannot accept attributes.
            </remarks>
      <param name="attributes">The parsers that match the element's attributes.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified attributes and children.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.
            </summary>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.
            </summary>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified children.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified children.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.
            </summary>
      <remarks>
            IParser is not covariant on TResult in Silverlight because <see cref="T:System.Collections.Generic.IEnumerable`1" /> is not covariant on T.
            For this reason, the <paramref name="content" /> parameter cannot accept attributes.
            </remarks>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parsers that match the element's attributes.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, having no attributes
            and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, having no attributes 
            and containing the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">An enumerable sequence containing the names of the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.Text">
      <summary>
            Gets a parser with a grammar that matches all characters, including whitespace, up to the start tag of an element.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Text" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.Comment">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;!-- and ending with --&gt;.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Comment" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.CData">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;![CDATA[ and ending with ]]&gt;.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_CData" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.AnyContent">
      <summary>
            Gets a parser with a grammar that matches any <see cref="P:Rxx.Parsers.XmlParserQueryContext`2.Text" />, <see cref="P:Rxx.Parsers.XmlParserQueryContext`2.Comment" /> or <see cref="P:Rxx.Parsers.XmlParserQueryContext`2.CData" /> content.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyContent" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.AnyElement">
      <summary>
            Gets a parser with a grammar that matches an XML element with any attributes or content.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyElement" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.AnyAttribute">
      <summary>
            Gets a parser with a grammar that matches an XML attribute.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Properties.Errors">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.EventIsNotCompatibleWithEventArgs">
      <summary>
              Looks up a localized string similar to The event member's delegate has an arguments parameter that is not compatible with System.EventArgs.  Member name: {0}..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.EventIsNotCompatibleWithEventHandler">
      <summary>
              Looks up a localized string similar to The event member's delegate is not compatible with System.EventHandler&lt;TEventArgs&gt;.  Member name: {0}..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.InlineParseNotSupported">
      <summary>
              Looks up a localized string similar to An in-line query cannot be parsed while the grammar is being defined..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.InlineParserWithoutGrammar">
      <summary>
              Looks up a localized string similar to The temporary in-line parser does not have a grammar..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.InvalidPairDirectionValue">
      <summary>
              Looks up a localized string similar to The PairDirection value is invalid..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.ParseCalledWhileParsing">
      <summary>
              Looks up a localized string similar to Parse cannot be called again until the current parse operation completes..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.ParseExceptionMessage">
      <summary>
              Looks up a localized string similar to Syntax error in parser input sequence..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.ParseExceptionMessageOverrideFormat">
      <summary>
              Looks up a localized string similar to {0}{1}Source index: {2}..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.ParseNotCalledOrFailed">
      <summary>
              Looks up a localized string similar to The operation is unavailable until after Parse has been called and it has completed successfully..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.ParserNextNotReady">
      <summary>
              Looks up a localized string similar to The Next property cannot be read until after Parse is called..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.ParseSubscribeCalledWhileParsing">
      <summary>
              Looks up a localized string similar to The parser does not allow new subscriptions until the current parse operation completes..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.PropertyDoesNotSupportChangeEvents">
      <summary>
              Looks up a localized string similar to The specified property does not support change events..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.PropertyExpressionContainsIndexer">
      <summary>
              Looks up a localized string similar to The specified expression contains an indexer..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.PropertyExpressionNotUnderstood">
      <summary>
              Looks up a localized string similar to The specified expression cannot be understood as a property..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.PropertyExpressionOwnerNotUnderstood">
      <summary>
              Looks up a localized string similar to The specified expression cannot be understood as a property being read from a local variable, field, another property, or a chain of fields and properties..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.PropertyExpressionTooComplex">
      <summary>
              Looks up a localized string similar to The specified expression contains more than just fields and properties..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.PropertyExpresssionOwnerNotDetermined">
      <summary>
              Looks up a localized string similar to The owner of the specified property could not be determined..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.PropertyIsReadOnly">
      <summary>
              Looks up a localized string similar to The specified property is read-only.  Property name: {0}..
            </summary>
    </member>
    <member name="T:Rxx.Properties.Text">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.DefaultDisposedSubscriptionMessage">
      <summary>
              Looks up a localized string similar to Disposed subscription..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.DefaultDisposingSubscriptionMessage">
      <summary>
              Looks up a localized string similar to Disposing subscription..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.DefaultOnCompletedMessage">
      <summary>
              Looks up a localized string similar to Observable completed..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.DefaultSubscribedMessage">
      <summary>
              Looks up a localized string similar to Subscribed to observable..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.DefaultSubscribingMessage">
      <summary>
              Looks up a localized string similar to Subscribing to observable..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.DisposedSubscriptionFormat">
      <summary>
              Looks up a localized string similar to Disposed subscription: {0}..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.DisposingSubscriptionFormat">
      <summary>
              Looks up a localized string similar to Disposing subscription: {0}..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.FileSystemWatcherBufferChangeFormat">
      <summary>
              Looks up a localized string similar to Increasing FileSystemWatcher buffer size from {0} to {1}..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.FileSystemWatcherBufferOverflowFormat">
      <summary>
              Looks up a localized string similar to FileSystemWatcher buffer overflow: {0}.
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.SubscribedFormat">
      <summary>
              Looks up a localized string similar to Subscribed to observable: {0}..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.SubscribingFormat">
      <summary>
              Looks up a localized string similar to Subscribing to observable: {0}..
            </summary>
    </member>
    <member name="T:System.Collections.Generic.OperationalEnumerable`2">
      <summary>
            Represents an enumerable that uses its unary and binary operator overloads as query operators.
            </summary>
      <typeparam name="TIn">Input type.</typeparam>
      <typeparam name="TOut">Output type.</typeparam>
      <invariant>source != null</invariant>
      <invariant>resultSelector != null</invariant>
      <invariant>binaryOperation != null</invariant>
      <invariant>add != null</invariant>
      <invariant>subtract != null</invariant>
      <invariant>multiply != null</invariant>
      <invariant>divide != null</invariant>
      <invariant>positive != null</invariant>
      <invariant>negative != null</invariant>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Addition(System.Collections.Generic.OperationalEnumerable{`0,`1},System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that adds the values in the specified enumerables 
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first enumerable.</param>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Add(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that adds the values in this enumerable to the values in the specified enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Addition(System.Collections.Generic.OperationalEnumerable{`0,`1},`0)">
      <summary>
            Creates a new operational enumerable that adds the values in the specified enumerable to the specified value
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The enumerable.</param>
      <param name="second">A value that is added to each value in the <paramref name="first" /> enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Add(`0)">
      <summary>
            Creates a new operational enumerable that adds the values in this enumerable to the specified value.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that is added to each value in this enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Subtraction(System.Collections.Generic.OperationalEnumerable{`0,`1},System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that subtracts the values in the specified enumerables 
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first enumerable.</param>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Subtract(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that subtracts the values in the specified enumerable from the values in this enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Subtraction(System.Collections.Generic.OperationalEnumerable{`0,`1},`0)">
      <summary>
            Creates a new operational enumerable that subtracts the specified value from the values in the specified enumerable
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The enumerable.</param>
      <param name="second">A value that is subtracted from each value in the <paramref name="first" /> enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Subtract(`0)">
      <summary>
            Creates a new operational enumerable that subtracts the specified value from the values in this enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that is subtracted from each value in this enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Multiply(System.Collections.Generic.OperationalEnumerable{`0,`1},System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that multiplies the values in the specified enumerables 
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first enumerable.</param>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Multiply(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that multiplies the values in this enumerable by the values in the specified enumerable.
            </summary>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Multiply(System.Collections.Generic.OperationalEnumerable{`0,`1},`0)">
      <summary>
            Creates a new operational enumerable that multiplies the values in the specified enumerable by the specified value
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The enumerable.</param>
      <param name="second">A value that is multiplied against each value in the <paramref name="first" /> enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Multiply(`0)">
      <summary>
            Creates a new operational enumerable that multiplies the values in this enumerable by the specified <paramref name="value" />.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that is multiplied against each value in this enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Division(System.Collections.Generic.OperationalEnumerable{`0,`1},System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that divides the values in the specified enumerables 
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first enumerable.</param>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Divide(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that divides the values in this enumerable by the values in the specified enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Division(System.Collections.Generic.OperationalEnumerable{`0,`1},`0)">
      <summary>
            Creates a new operational enumerable that divides the values in the specified enumerable by the specified value
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The enumerable.</param>
      <param name="second">A value that divides each value in the <paramref name="first" /> enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Divide(`0)">
      <summary>
            Creates a new operational enumerable that divides the values in this enumerable by the specified <paramref name="value" />.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that divides each value in this enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_UnaryPlus(System.Collections.Generic.OperationalEnumerable{`0,`1})">
      <summary>
            Creates a new operational enumerable that ensures the sign of the specified enumerable's values are positive.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="enumerable">The enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>enumerable != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Plus">
      <summary>
            Creates a new operational enumerable that ensures the sign of this enumerable's values are positive.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_UnaryNegation(System.Collections.Generic.OperationalEnumerable{`0,`1})">
      <summary>
            Creates a new operational enumerable that ensures the sign of the specified enumerable's values are negative.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="enumerable">The enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>enumerable != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Negate">
      <summary>
            Creates a new operational enumerable that ensures the sign of this enumerable's values are negative.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Collections.Generic.OperationalEnumerable`1">
      <summary>
            Represents an enumerable that uses its unary and binary operator overloads as query operators.
            </summary>
      <typeparam name="T">Input and output type.</typeparam>
    </member>
    <member name="T:System.ComponentModel.MemberDescriptorExtensions">
      <summary>
            Provides extension methods for <see cref="T:System.ComponentModel.PropertyDescriptor" /> and <see cref="T:System.ComponentModel.EventDescriptor" />.
            </summary>
    </member>
    <member name="M:System.ComponentModel.MemberDescriptorExtensions.PropertyChanged(System.ComponentModel.PropertyDescriptor,System.Object)">
      <summary>
            Returns an observable sequence of property changed notifications from the 
            specified <paramref name="property" /> descriptor.
            </summary>
      <param name="property">The descriptor from which to create an observable sequence of changed notifications.</param>
      <param name="source">The object to which the <paramref name="property" /> belongs.</param>
      <returns>An observable sequence of property changed notifications.</returns>
      <exception cref="T:System.ArgumentException">The specified property does not support change events.</exception>
      <requires>property != null</requires>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;PropertyChangedEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Either">
      <summary>
            Provides <see langword="static" /> factory methods for creating instances of <see cref="T:System.Either`2" /> objects.
            </summary>
    </member>
    <member name="M:System.Either.Left``2(``0)">
      <summary>
            Creates a new instance of <see cref="T:System.Either`2" /> with the specified <paramref name="value" />
            and <see cref="P:System.Either`2.IsLeft" /> set to <see langword="true" />.
            </summary>
      <typeparam name="TLeft">Type of the left value.</typeparam>
      <typeparam name="TRight">Type of the right value.</typeparam>
      <param name="value">The left value.</param>
      <returns>A new instance of <see cref="T:System.Either`2" /> with the specified <paramref name="value" />
            and <see cref="P:System.Either`2.IsLeft" /> set to <see langword="true" />.</returns>
      <ensures>Contract.Result&lt;Either&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Either.Right``2(``1)">
      <summary>
            Creates a new instance of <see cref="T:System.Either`2" /> with the specified <paramref name="value" />
            and <see cref="P:System.Either`2.IsLeft" /> set to <see langword="false" />.
            </summary>
      <typeparam name="TLeft">Type of the left value.</typeparam>
      <typeparam name="TRight">Type of the right value.</typeparam>
      <param name="value">The right value.</param>
      <returns>A new instance of <see cref="T:System.Either`2" /> with the specified <paramref name="value" />
            and <see cref="P:System.Either`2.IsLeft" /> set to <see langword="false" />.</returns>
      <ensures>Contract.Result&lt;Either&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Either.LeftValue`2">
      <summary>
            Holds the value of the left side of an <see cref="T:System.Either`2" />.
            </summary>
      <typeparam name="TLeft">Type of the left side.</typeparam>
      <typeparam name="TRight">Type of the right side.</typeparam>
    </member>
    <member name="T:System.Either`2">
      <summary>
            Represents one of two possible values.
            </summary>
      <typeparam name="TLeft">Type of the left value.</typeparam>
      <typeparam name="TRight">Type of the right value.</typeparam>
    </member>
    <member name="M:System.Either`2.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:System.Either`2" /> class for derived classes.
            </summary>
    </member>
    <member name="M:System.Either`2.Switch(System.Action{`0},System.Action{`1})">
      <summary>
            Invokes the specified <paramref name="left" /> or <paramref name="right" /> action depending upon 
            the value of <see cref="P:System.Either`2.IsLeft" />.
            </summary>
      <param name="left">The action to be invoked when <see cref="P:System.Either`2.IsLeft" /> is <see langword="true" />.</param>
      <param name="right">The action to be invoked when <see cref="P:System.Either`2.IsLeft" /> is <see langword="false" />.</param>
      <requires>left != null</requires>
      <requires>right != null</requires>
    </member>
    <member name="M:System.Either`2.Switch``1(System.Func{`0,``0},System.Func{`1,``0})">
      <summary>
            Invokes the specified <paramref name="left" /> or <paramref name="right" /> function depending upon 
            the value of <see cref="P:System.Either`2.IsLeft" />.
            </summary>
      <typeparam name="TResult">The type of the result.</typeparam>
      <param name="left">The function to be invoked when <see cref="P:System.Either`2.IsLeft" /> is <see langword="true" />.</param>
      <param name="right">The function to be invoked when <see cref="P:System.Either`2.IsLeft" /> is <see langword="false" />.</param>
      <returns>The return value of either the <paramref name="left" /> or <paramref name="right" /> function
            depending upon the value of <see cref="P:System.Either`2.IsLeft" />.</returns>
      <requires>left != null</requires>
      <requires>right != null</requires>
    </member>
    <member name="P:System.Either`2.IsLeft">
      <summary>
            Gets a value indicating whether the object holds the left value or the right value.
            </summary>
      <value>
        <see langword="true" /> if the object holds the left value; otherwise, <see langword="false" />.</value>
    </member>
    <member name="P:System.Either`2.Left">
      <summary>
            Gets the left value when <see cref="P:System.Either`2.IsLeft" /> is <see langword="true" />.
            </summary>
      <value>The left value when <see cref="P:System.Either`2.IsLeft" /> is <see langword="true" />.</value>
      <getter>
        <requires>IsLeft</requires>
      </getter>
    </member>
    <member name="P:System.Either`2.Right">
      <summary>
            Gets the right value when <see cref="P:System.Either`2.IsLeft" /> is <see langword="false" />.
            </summary>
      <value>The right value when <see cref="P:System.Either`2.IsLeft" /> is <see langword="false" />.</value>
      <getter>
        <requires>!IsLeft</requires>
      </getter>
    </member>
    <member name="M:System.Either.LeftValue`2.#ctor(`0)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Either.LeftValue`2" /> class.
            </summary>
      <param name="value">The left value.</param>
    </member>
    <member name="M:System.Either.LeftValue`2.Switch(System.Action{`0},System.Action{`1})">
      <summary>
            Invokes the specified <paramref name="left" /> action.
            </summary>
      <param name="left">The action to be invoked.</param>
      <param name="right">This parameter is ignored.</param>
      <requires inheritedFrom="M:System.Either`2.Switch(System.Action{`0},System.Action{`1})" inheritedFromTypeName="Either">left != null</requires>
      <requires inheritedFrom="M:System.Either`2.Switch(System.Action{`0},System.Action{`1})" inheritedFromTypeName="Either">right != null</requires>
    </member>
    <member name="M:System.Either.LeftValue`2.Switch``1(System.Func{`0,``0},System.Func{`1,``0})">
      <summary>
            Invokes the specified <paramref name="left" /> function.
            </summary>
      <typeparam name="TResult">The type of the result.</typeparam>
      <param name="left">The function to be invoked.</param>
      <param name="right">This parameter is ignored.</param>
      <returns>The return value of the <paramref name="left" /> function</returns>
      <requires inheritedFrom="M:System.Either`2.Switch``1(System.Func{`0,``0},System.Func{`1,``0})" inheritedFromTypeName="Either">left != null</requires>
      <requires inheritedFrom="M:System.Either`2.Switch``1(System.Func{`0,``0},System.Func{`1,``0})" inheritedFromTypeName="Either">right != null</requires>
    </member>
    <member name="P:System.Either.LeftValue`2.IsLeft">
      <summary>
            Gets whether the object holds the left value or the right value.
            </summary>
      <value>Always returns <see langword="true" />.</value>
    </member>
    <member name="P:System.Either.LeftValue`2.Left">
      <summary>
            Gets the left value when <see cref="P:System.Either.LeftValue`2.IsLeft" /> is <see langword="true" />.
            </summary>
      <value>Always returns the left value.</value>
      <getter>
        <requires inheritedFrom="M:System.Either`2.get_Left" inheritedFromTypeName="Either">IsLeft</requires>
      </getter>
    </member>
    <member name="P:System.Either.LeftValue`2.Right">
      <summary>
            Gets the right value when <see cref="P:System.Either.LeftValue`2.IsLeft" /> is <see langword="false" />.
            </summary>
      <value>Always throws <strong>System.Diagnostics.Contracts.ContractException</strong>.</value>
      <getter>
        <requires inheritedFrom="M:System.Either`2.get_Right" inheritedFromTypeName="Either">!IsLeft</requires>
      </getter>
    </member>
    <member name="T:System.Either.RightValue`2">
      <summary>
            Holds the value of the right side of an <see cref="T:System.Either`2" />.
            </summary>
      <typeparam name="TLeft">Type of the left side.</typeparam>
      <typeparam name="TRight">Type of the right side.</typeparam>
    </member>
    <member name="M:System.Either.RightValue`2.#ctor(`1)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Either.RightValue`2" /> class.
            </summary>
      <param name="value">The right value.</param>
    </member>
    <member name="M:System.Either.RightValue`2.Switch(System.Action{`0},System.Action{`1})">
      <summary>
            Invokes the specified <paramref name="right" /> action.
            </summary>
      <param name="left">This parameter is ignored.</param>
      <param name="right">The action to be invoked.</param>
      <requires inheritedFrom="M:System.Either`2.Switch(System.Action{`0},System.Action{`1})" inheritedFromTypeName="Either">left != null</requires>
      <requires inheritedFrom="M:System.Either`2.Switch(System.Action{`0},System.Action{`1})" inheritedFromTypeName="Either">right != null</requires>
    </member>
    <member name="M:System.Either.RightValue`2.Switch``1(System.Func{`0,``0},System.Func{`1,``0})">
      <summary>
            Invokes the specified <paramref name="right" /> function.
            </summary>
      <typeparam name="TResult">The type of the result.</typeparam>
      <param name="left">This parameter is ignored.</param>
      <param name="right">The function to be invoked.</param>
      <returns>The return value of the <paramref name="right" /> function.</returns>
      <requires inheritedFrom="M:System.Either`2.Switch``1(System.Func{`0,``0},System.Func{`1,``0})" inheritedFromTypeName="Either">left != null</requires>
      <requires inheritedFrom="M:System.Either`2.Switch``1(System.Func{`0,``0},System.Func{`1,``0})" inheritedFromTypeName="Either">right != null</requires>
    </member>
    <member name="P:System.Either.RightValue`2.IsLeft">
      <summary>
            Gets whether the object holds the left value or the right value.
            </summary>
      <value>Always returns <see langword="false" />.</value>
    </member>
    <member name="P:System.Either.RightValue`2.Left">
      <summary>
            Gets the left value when <see cref="P:System.Either.RightValue`2.IsLeft" /> is <see langword="true" />.
            </summary>
      <value>Always throws <strong>System.Diagnostics.Contracts.ContractException</strong>.</value>
      <getter>
        <requires inheritedFrom="M:System.Either`2.get_Left" inheritedFromTypeName="Either">IsLeft</requires>
      </getter>
    </member>
    <member name="P:System.Either.RightValue`2.Right">
      <summary>
            Gets the right value when <see cref="P:System.Either.RightValue`2.IsLeft" /> is <see langword="false" />.
            </summary>
      <value>Always returns the left value.</value>
      <getter>
        <requires inheritedFrom="M:System.Either`2.get_Right" inheritedFromTypeName="Either">!IsLeft</requires>
      </getter>
    </member>
    <member name="T:System.Linq.Enumerable2">
      <summary>
            Provides a set of <see langword="static" /> methods for query operations over enumerable sequences.
            </summary>
    </member>
    <member name="M:System.Linq.Enumerable2.Throw``1(System.Exception)">
      <summary>
            Creates and enumerable sequence that, when enumerated, throws the specified <paramref name="exception" />.
            </summary>
      <typeparam name="TSource">The type of the elements of the generated enumerable sequence.</typeparam>
      <param name="exception">The <see cref="T:System.Exception" /> to be thrown when the returned sequence is enumerated.</param>
      <returns>An enumerable sequence that throws the specified <paramref name="exception" />.</returns>
      <requires>exception != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.Enumerable2.Do``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
            Invokes the specified <paramref name="onNext" /> action for its side-effects.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values on which to invoke <paramref name="onNext" /> for its side-effects.</param>
      <param name="onNext">Invoked for each value in <paramref name="source" />.</param>
      <returns>An enumerable sequence containing the same values as the <paramref name="source" /> sequence.</returns>
    </member>
    <member name="M:System.Linq.Enumerable2.Do``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0},System.Action)">
      <summary>
            Invokes the specified actions for their side-effects.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values on which to invoke the specified actions for their side-effects.</param>
      <param name="onNext">Invoked for each value in <paramref name="source" />.</param>
      <param name="onCompleted">Invoked when the sequence terminates successfully.</param>
      <returns>An enumerable sequence containing the same values as the <paramref name="source" /> sequence.</returns>
      <requires>source != null</requires>
      <requires>onNext != null</requires>
      <requires>onCompleted != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.Enumerable2.Do``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0},System.Action{System.Exception})">
      <summary>
            Invokes the specified actions for their side-effects.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values on which to invoke the specified actions for their side-effects.</param>
      <param name="onNext">Invoked for each value in <paramref name="source" />.</param>
      <param name="onError">Invoked when the sequence throws an exception.</param>
      <returns>An enumerable sequence containing the same values as the <paramref name="source" /> sequence.</returns>
      <requires>source != null</requires>
      <requires>onNext != null</requires>
      <requires>onError != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.Enumerable2.Do``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0},System.Action{System.Exception},System.Action)">
      <summary>
            Invokes the specified actions for their side-effects.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values on which to invoke the specified actions for their side-effects.</param>
      <param name="onNext">Invoked for each value in <paramref name="source" />.</param>
      <param name="onError">Invoked when the sequence throws an exception.</param>
      <param name="onCompleted">Invoked when the sequence terminates successfully.</param>
      <returns>An enumerable sequence containing the same values as the <paramref name="source" /> sequence.</returns>
      <requires>source != null</requires>
      <requires>onNext != null</requires>
      <requires>onError != null</requires>
      <requires>onCompleted != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.Enumerable2.Do``1(System.Collections.Generic.IEnumerable{``0},System.IObserver{``0})">
      <summary>
            Notifies the specified <paramref name="observer" /> of values, an exception and completion for its side-effects.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values on which to notify the specified <paramref name="observer" />.</param>
      <param name="observer">An object to observe each value in the <paramref name="source" /> sequence, an exception if thrown 
            or completion if the sequence terminates successfully.</param>
      <returns>An enumerable sequence containing the same values as the <paramref name="source" /> sequence.</returns>
    </member>
    <member name="M:System.Linq.Enumerable2.ForEach``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Enumerates the specified sequence for its side-effects.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">An enumerable sequence to enumerate for its side-effects.</param>
      <requires>source != null</requires>
    </member>
    <member name="M:System.Linq.Enumerable2.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
            Invokes the specified <paramref name="onNext" /> action for its side-effects.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values on which to invoke <paramref name="onNext" /> for its side-effects.</param>
      <param name="onNext">Invoked for each value in <paramref name="source" />.</param>
      <requires>source != null</requires>
      <requires>onNext != null</requires>
    </member>
    <member name="M:System.Linq.Enumerable2.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0},System.Action)">
      <summary>
            Invokes the specified actions for their side-effects.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values on which to invoke the specified actions for their side-effects.</param>
      <param name="onNext">Invoked for each value in <paramref name="source" />.</param>
      <param name="onCompleted">Invoked when the sequence terminates successfully.</param>
      <requires>source != null</requires>
      <requires>onNext != null</requires>
      <requires>onCompleted != null</requires>
    </member>
    <member name="M:System.Linq.Enumerable2.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0},System.Action{System.Exception})">
      <summary>
            Invokes the specified actions for their side-effects.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values on which to invoke the specified actions for their side-effects.</param>
      <param name="onNext">Invoked for each value in <paramref name="source" />.</param>
      <param name="onError">Invoked when the sequence throws an exception.</param>
      <requires>source != null</requires>
      <requires>onNext != null</requires>
      <requires>onError != null</requires>
    </member>
    <member name="M:System.Linq.Enumerable2.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0},System.Action{System.Exception},System.Action)">
      <summary>
            Invokes the specified actions for their side-effects.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values on which to invoke the specified actions for their side-effects.</param>
      <param name="onNext">Invoked for each value in <paramref name="source" />.</param>
      <param name="onError">Invoked when the sequence throws an exception.</param>
      <param name="onCompleted">Invoked when the sequence terminates successfully.</param>
      <requires>source != null</requires>
      <requires>onNext != null</requires>
      <requires>onError != null</requires>
      <requires>onCompleted != null</requires>
    </member>
    <member name="M:System.Linq.Enumerable2.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.IObserver{``0})">
      <summary>
            Notifies the specified <paramref name="observer" /> of values, an exception and completion for its side-effects.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values on which to notify the specified <paramref name="observer" />.</param>
      <param name="observer">An object to observe each value in the <paramref name="source" /> sequence, an exception if thrown 
            or completion if the sequence terminates successfully.</param>
      <requires>source != null</requires>
      <requires>observer != null</requires>
    </member>
    <member name="M:System.Linq.Enumerable2.StartWith``1(System.Collections.Generic.IEnumerable{``0},``0)">
      <summary>
            Prepends the specified <paramref name="value" /> to the specified enumerable sequence.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values on which to prepend the specified <paramref name="value" />.</param>
      <param name="value">The value to prepend to the specified enumerable sequence.</param>
      <returns>An enumerable sequence starting with the specified <paramref name="value" />, followed by
            the specified sequence.</returns>
    </member>
    <member name="M:System.Linq.Enumerable2.Concat``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
      <summary>
            Concatenates the specified enumerable sequences into a single sequence.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="sources" />.</typeparam>
      <param name="sources">The sequence of sequences to be concatenated.</param>
      <returns>An enumerable sequence containing the values of the specified sequences concatenated.</returns>
    </member>
    <member name="M:System.Linq.Enumerable2.Repeat``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>
            Repeats the specified enumerable sequence the specified number of times.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to be repeated the specified number of times.</param>
      <param name="repeatCount">The number of times to repeat the specified sequence.</param>
      <returns>An enumerable sequence containing the specified sequence repeated the specified number of times.</returns>
    </member>
    <member name="M:System.Linq.Enumerable2.Catch``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Catches any exception thrown by the specified enumerable sequence and resumes with the next
            specified sequence until it terminates.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence in which to catch any exception.</param>
      <param name="nextSource">The sequence with which to resume if the specified <paramref name="source" /> sequence
            throws an exception.</param>
      <returns>An enumerable sequence containing the values from the specified <paramref name="source" /> sequence until 
            it terminates sucessfully; otherwise, if it throws, then the sequence resumes with the next specified sequence 
            until that terminates.</returns>
    </member>
    <member name="M:System.Linq.Enumerable2.Scan``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})">
      <summary>
            Applies an accumulator function over a sequence and returns each intermediate result.
            The specified seed value is used as the initial accumulator value.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <typeparam name="TAccumulate">The type of the accumulated elements in the returned sequence.</typeparam>
      <param name="source">The sequence from which values are accumulated.</param>
      <param name="seed">The initial accumulator value.</param>
      <param name="accumulator">A function that receives each element of the specified sequence and the current 
            accumulation, and returns the new accumulation.</param>
      <returns>An enumerable sequence of accumulated values from the specified sequence.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionExtensions">
      <summary>
            Provides extension methods for <see cref="T:System.Linq.Expressions.Expression`1" /> objects.
            </summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionExtensions.GetPropertyInfo``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>
            Gets property information for the specified <paramref name="property" /> expression.
            </summary>
      <typeparam name="TSource">Type of the parameter in the <paramref name="property" /> expression.</typeparam>
      <typeparam name="TValue">Type of the property's value.</typeparam>
      <param name="property">The expression from which to retrieve the property information.</param>
      <returns>Property information for the specified expression.</returns>
      <exception cref="T:System.ArgumentException">The expression is not understood.</exception>
      <requires>property != null</requires>
      <ensures>Contract.Result&lt;PropertyInfo&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionExtensions.GetPropertyInfo``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Object@)">
      <summary>
            Gets property information for the specified <paramref name="property" /> expression.
            </summary>
      <typeparam name="TValue">Type of the property's value.</typeparam>
      <param name="property">The expression from which to retrieve the property information.</param>
      <param name="owner">Instance of the object that defines the specified property.</param>
      <returns>Property information for the specified expression.</returns>
      <exception cref="T:System.ArgumentException">The expression is too complex or is not understood.</exception>
      <exception cref="T:System.ArgumentException">The expression does not represent a chain of one or more fields and properties, ending with a property.</exception>
      <exception cref="T:System.ArgumentException">The expression contains an indexer.</exception>
      <exception cref="T:System.ArgumentException">The owner cannot be determined from the expression.</exception>
      <requires>property != null</requires>
      <ensures>Contract.Result&lt;PropertyInfo&gt;() != null</ensures>
      <ensures>Contract.ValueAtReturn(out owner) != null</ensures>
    </member>
    <member name="T:System.Linq.OperationalEnumerable">
      <summary>
            Provides extension methods that convert an <see cref="T:System.Collections.Generic.IEnumerable`1" /> into an <see cref="T:System.Collections.Generic.OperationalEnumerable`2" />.
            </summary>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.SByte})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.SByte" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.SByte},System.Func{System.Collections.Generic.IEnumerable{System.SByte},System.Collections.Generic.IEnumerable{System.SByte},System.Func{System.SByte,System.SByte,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.SByte" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.SByte},System.Func{System.Collections.Generic.IEnumerable{System.SByte},System.Collections.Generic.IEnumerable{System.SByte},System.Func{System.SByte,System.SByte,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.SByte" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Collections.Generic.OperationalEnumerable`2" />.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Byte})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Byte" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Byte},System.Func{System.Collections.Generic.IEnumerable{System.Byte},System.Collections.Generic.IEnumerable{System.Byte},System.Func{System.Byte,System.Byte,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Byte" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Byte},System.Func{System.Collections.Generic.IEnumerable{System.Byte},System.Collections.Generic.IEnumerable{System.Byte},System.Func{System.Byte,System.Byte,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Byte" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Collections.Generic.OperationalEnumerable`2" />.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Char})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Char" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Char},System.Func{System.Collections.Generic.IEnumerable{System.Char},System.Collections.Generic.IEnumerable{System.Char},System.Func{System.Char,System.Char,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Char" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Char},System.Func{System.Collections.Generic.IEnumerable{System.Char},System.Collections.Generic.IEnumerable{System.Char},System.Func{System.Char,System.Char,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Char" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Collections.Generic.OperationalEnumerable`2" />.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int16})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Int16" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int16},System.Func{System.Collections.Generic.IEnumerable{System.Int16},System.Collections.Generic.IEnumerable{System.Int16},System.Func{System.Int16,System.Int16,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Int16" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int16},System.Func{System.Collections.Generic.IEnumerable{System.Int16},System.Collections.Generic.IEnumerable{System.Int16},System.Func{System.Int16,System.Int16,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Int16" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Collections.Generic.OperationalEnumerable`2" />.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.UInt16})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.UInt16" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.UInt16},System.Func{System.Collections.Generic.IEnumerable{System.UInt16},System.Collections.Generic.IEnumerable{System.UInt16},System.Func{System.UInt16,System.UInt16,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.UInt16" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.UInt16},System.Func{System.Collections.Generic.IEnumerable{System.UInt16},System.Collections.Generic.IEnumerable{System.UInt16},System.Func{System.UInt16,System.UInt16,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.UInt16" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Collections.Generic.OperationalEnumerable`2" />.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Int32" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Int32" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.UInt32})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.UInt32" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;uint&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.UInt32},System.Func{System.Collections.Generic.IEnumerable{System.UInt32},System.Collections.Generic.IEnumerable{System.UInt32},System.Func{System.UInt32,System.UInt32,System.UInt32},System.Collections.Generic.IEnumerable{System.UInt32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.UInt32" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;uint&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int64})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Int64" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;long&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int64},System.Func{System.Collections.Generic.IEnumerable{System.Int64},System.Collections.Generic.IEnumerable{System.Int64},System.Func{System.Int64,System.Int64,System.Int64},System.Collections.Generic.IEnumerable{System.Int64}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Int64" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;long&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.UInt64})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.UInt64" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;ulong&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.UInt64},System.Func{System.Collections.Generic.IEnumerable{System.UInt64},System.Collections.Generic.IEnumerable{System.UInt64},System.Func{System.UInt64,System.UInt64,System.UInt64},System.Collections.Generic.IEnumerable{System.UInt64}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.UInt64" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;ulong&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Single})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Single" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;float&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Single},System.Func{System.Collections.Generic.IEnumerable{System.Single},System.Collections.Generic.IEnumerable{System.Single},System.Func{System.Single,System.Single,System.Single},System.Collections.Generic.IEnumerable{System.Single}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Single" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;float&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Double" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;double&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Double},System.Func{System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Func{System.Double,System.Double,System.Double},System.Collections.Generic.IEnumerable{System.Double}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Double" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;double&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Decimal})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Decimal" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;decimal&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Decimal},System.Func{System.Collections.Generic.IEnumerable{System.Decimal},System.Collections.Generic.IEnumerable{System.Decimal},System.Func{System.Decimal,System.Decimal,System.Decimal},System.Collections.Generic.IEnumerable{System.Decimal}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Decimal" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;decimal&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0},System.Collections.Generic.IEnumerable{``0}},System.Func{``0,``0,``0},System.Func{``0,``0,``0},System.Func{``0,``0,``0},System.Func{``0,``0,``0},System.Func{``0,``0},System.Func{``0,``0})">
      <summary>
            Creates an <see cref="T:System.Collections.Generic.OperationalEnumerable`1" /> for the specified <paramref name="source" /> from the specified operators.
            </summary>
      <typeparam name="T">The type of objects to enumerate.</typeparam>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="add">The addition operator.</param>
      <param name="subtract">The subtraction operator.</param>
      <param name="multiply">The multiplication operator.</param>
      <param name="divide">The division operator.</param>
      <param name="positive">The plus operator.</param>
      <param name="negative">The negation operator.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`1" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational``2(System.Collections.Generic.IEnumerable{``0},System.Func{System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.OperationalEnumerable{``1}},System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``1},System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``0,``1},System.Func{``0,``0,``1},System.Func{``0,``0,``1},System.Func{``0,``0,``1},System.Func{``0,``1},System.Func{``0,``1})">
      <summary>
            Creates an <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <paramref name="source" /> from the specified operators.
            </summary>
      <typeparam name="TIn">The type of input to enumerate.</typeparam>
      <typeparam name="TOut">The type of output that each operation generates.</typeparam>
      <param name="source">The enumerable to be converted.</param>
      <param name="resultSelector">Projects the result sequence into an <see cref="T:System.Collections.Generic.OperationalEnumerable`1" />.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="add">The addition operator.</param>
      <param name="subtract">The subtraction operator.</param>
      <param name="multiply">The multiplication operator.</param>
      <param name="divide">The division operator.</param>
      <param name="positive">The plus operator.</param>
      <param name="negative">The negation operator.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TIn, TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Maybe">
      <summary>
            Provides methods that construct instances of <see cref="T:System.Maybe`1" />.
            </summary>
    </member>
    <member name="M:System.Maybe.Empty``1">
      <summary>
            Gets a <see cref="T:System.Maybe`1" /> that represents a missing instance of <typeparamref name="T" />.
            </summary>
      <typeparam name="T">Type of object.</typeparam>
      <returns>A <see cref="T:System.Maybe`1" /> with <see cref="P:System.Maybe`1.HasValue" /> set to <see langword="false" />.</returns>
      <ensures>!Contract.Result&lt;Maybe&lt;T&gt;&gt;().HasValue</ensures>
    </member>
    <member name="M:System.Maybe.Return``1(``0)">
      <summary>
            Creates a new instance of <see cref="T:System.Maybe`1" /> with the specified <paramref name="value" />.
            </summary>
      <typeparam name="T">Type of <paramref name="value" /></typeparam>
      <param name="value">The value assigned to the <see cref="P:System.Maybe`1.Value" /> property.</param>
      <returns>A new instance of <see cref="T:System.Maybe`1" /> with the specified <paramref name="value" /> and 
            <see cref="P:System.Maybe`1.HasValue" /> set to <see langword="true" />.</returns>
      <ensures>Contract.Result&lt;Maybe&lt;T&gt;&gt;().HasValue</ensures>
      <ensures>object.Equals(Contract.Result&lt;Maybe&lt;T&gt;&gt;().Value, value)</ensures>
    </member>
    <member name="T:System.Maybe`1">
      <summary>
            Represents an instance of an object or a missing instance of an object.
            </summary>
      <typeparam name="T">Type of object.</typeparam>
    </member>
    <member name="F:System.Maybe`1.Empty">
      <summary>
            Indicates a missing instance of <typeparamref name="T" />.
            </summary>
    </member>
    <member name="M:System.Maybe`1.#ctor(`0)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Maybe`1" /> struct with the specified available <paramref name="value" />.
            </summary>
      <remarks>
            Constructing a <see cref="T:System.Maybe`1" /> instance with this constructor always sets <see cref="P:System.Maybe`1.HasValue" /> to <see langword="true" />.
            </remarks>
      <param name="value">The value assigned to the <see cref="P:System.Maybe`1.Value" /> property.</param>
      <ensures>Contract.ValueAtReturn(out hasValue)</ensures>
      <ensures>object.Equals(Contract.ValueAtReturn(out this.value), value)</ensures>
    </member>
    <member name="M:System.Maybe`1.op_Equality(System.Maybe{`0},System.Maybe{`0})">
      <summary>
            Determines the equality of two <see cref="T:System.Maybe`1" /> values.
            </summary>
      <param name="first">The first value.</param>
      <param name="second">The second value.</param>
      <returns>
        <see langword="true" /> if the <paramref name="first" /> value equals the <paramref name="second" /> value; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Maybe`1.op_Inequality(System.Maybe{`0},System.Maybe{`0})">
      <summary>
            Determines the inequality of two <see cref="T:System.Maybe`1" /> values.
            </summary>
      <param name="first">The first value.</param>
      <param name="second">The second value.</param>
      <returns>
        <see langword="true" /> if the <paramref name="first" /> value does not equal the <paramref name="second" /> value; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Maybe`1.Equals(System.Object)">
      <summary>
            Determines the equality of this instance and the specified <paramref name="obj" />.
            </summary>
      <param name="obj">The object that is compared to this instance.</param>
      <returns>
        <see langword="true" /> if this instance equals the specified <paramref name="obj" />; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Maybe`1.Equals(System.Maybe{`0})">
      <summary>
            Determines the equality of this instance and the <paramref name="other" /> instance.
            </summary>
      <param name="other">The instance that is compared to this instance.</param>
      <returns>
        <see langword="true" /> if this instance equals the <paramref name="other" /> instance; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Maybe`1.GetHashCode">
      <summary>
            Gets the hash code of this instance.
            </summary>
      <returns>-1 if <see cref="P:System.Maybe`1.HasValue" /> is <see langword="false" /> and 0 if <see cref="P:System.Maybe`1.Value" /> is <see langword="null" />; otherwise, the hash code of <see cref="P:System.Maybe`1.Value" />.</returns>
    </member>
    <member name="M:System.Maybe`1.ToString">
      <summary>
            Returns the string representation of <see cref="P:System.Maybe`1.Value" />.
            </summary>
      <returns>String that represents this instance.</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:System.Maybe`1.HasValue">
      <summary>
            Gets a value indicating whether <see cref="P:System.Maybe`1.Value" /> is available.
            </summary>
      <value>
        <see langword="true" /> if <see cref="P:System.Maybe`1.Value" /> is available; otherwise, <see langword="false" />.</value>
    </member>
    <member name="P:System.Maybe`1.Value">
      <summary>
            Gets the value when <see cref="P:System.Maybe`1.HasValue" /> is <see langword="true" />.
            </summary>
      <getter>
        <requires>HasValue</requires>
      </getter>
    </member>
    <member name="T:System.Net.NetworkInformation.ObservableNetworkChange">
      <summary>
            Provides common properties for subscribing to changes in network status.
            </summary>
    </member>
    <member name="P:System.Net.NetworkInformation.ObservableNetworkChange.NetworkAvailability">
      <summary>
            Gets an observable that will notify the subscriber of current network availability and then any changes to network availability.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservable&lt;bool&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:System.Net.ObservableWebClient">
      <summary>
            Provides common methods for asynchronously sending data to and observing data from a resource identified by a URI.
            </summary>
    </member>
    <member name="M:System.Net.ObservableWebClient.DownloadString(System.Uri)">
      <summary>
            Downloads the specified resource as a <see cref="T:System.String" />.
            </summary>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <returns>An observable that caches the result of the download and replays it to observers.</returns>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.DownloadStringObservable(System.Net.WebClient,System.Uri)">
      <summary>
            Downloads the specified resource as a <see cref="T:System.String" />.
            </summary>
      <param name="client">The object that downloads the resource.</param>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <returns>An observable that caches the result of the download and replays it to observers.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.OpenRead(System.Uri)">
      <summary>
            Downloads the specified resource as a <see cref="T:System.IO.Stream" />.
            </summary>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <returns>An observable containing the readable stream that reads data from the resource.</returns>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Stream&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.OpenReadWithProgress(System.Uri)">
      <summary>
            Downloads the specified resource as a <see cref="T:System.IO.Stream" /> and includes a channel for progress notifications.
            </summary>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <returns>A paired observable that pushes progress notifications through the left channel and 
            contains the readable stream that reads data from the resource in the right channel.</returns>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;DownloadProgressChangedEventArgs, Stream&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.OpenReadObservable(System.Net.WebClient,System.Uri)">
      <summary>
            Downloads the specified resource as a <see cref="T:System.IO.Stream" />.
            </summary>
      <param name="client">The object that downloads the resource.</param>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <returns>An observable containing the readable stream that reads data from the resource.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Stream&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.OpenReadWithProgress(System.Net.WebClient,System.Uri)">
      <summary>
            Downloads the specified resource as a <see cref="T:System.IO.Stream" /> and includes a channel for progress notifications.
            </summary>
      <param name="client">The object that downloads the resource.</param>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <returns>A paired observable that pushes progress notifications through the left channel and 
            contains the readable stream that reads data from the resource in the right channel.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;DownloadProgressChangedEventArgs, Stream&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.OpenWrite(System.Uri,System.String)">
      <summary>
            Opens a writeable stream to the specified resource.
            </summary>
      <param name="address">The URI of the resource to receive the stream.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <returns>An observable containing the writeable stream that sends data to the resource.</returns>
      <requires>address != null</requires>
      <requires>method != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Stream&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.OpenWriteObservable(System.Net.WebClient,System.Uri,System.String)">
      <summary>
            Opens a writeable stream to the specified resource.
            </summary>
      <param name="client">The object that uploads to the resource.</param>
      <param name="address">The URI of the resource to receive the stream.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <returns>An observable containing the writeable stream that sends data to the resource.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <requires>method != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Stream&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.UploadString(System.Uri,System.String,System.String)">
      <summary>
            Uploads a string to the specified resource.
            </summary>
      <param name="address">The URI of the resource to receive the string.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <param name="data">The string to send to the resource.</param>
      <returns>An observable that caches the response from the server and replays it to observers.</returns>
      <requires>address != null</requires>
      <requires>method != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.UploadStringObservable(System.Net.WebClient,System.Uri,System.String,System.String)">
      <summary>
            Uploads a string to the specified resource.
            </summary>
      <param name="client">The object that uploads to the resource.</param>
      <param name="address">The URI of the resource to receive the string.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <param name="data">The string to send to the resource.</param>
      <returns>An observable that caches the response from the server and replays it to observers.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <requires>method != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Net.ObservableWebRequest">
      <summary>
            Provides <see langword="static" /> methods that return observable sequences for various asynchronous methods defined 
            by the <see cref="T:System.Net.WebRequest" /> and <see cref="T:System.Net.HttpWebRequest" /> classes.
            </summary>
    </member>
    <member name="M:System.Net.ObservableWebRequest.GetRequestStreamObservable(System.Net.WebRequest)">
      <summary>
            Creates a <see cref="T:System.IO.Stream" /> for writing data to the Internet resource.
            </summary>
      <param name="request">The <see cref="T:System.Net.WebRequest" /> that provides the writable stream.</param>
      <returns>A singleton observable containing the writable <see cref="T:System.IO.Stream" />.</returns>
      <requires>request != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Stream&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebRequest.GetResponseObservable(System.Net.WebRequest)">
      <summary>
            Returns a response to an Internet request.
            </summary>
      <param name="request">The <see cref="T:System.Net.WebRequest" /> that creates the response.</param>
      <returns>A singleton observable containing the response.</returns>
      <requires>request != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;WebResponse&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebRequest.GetResponseObservable(System.Net.HttpWebRequest)">
      <summary>
            Returns a response to an Internet request.
            </summary>
      <param name="request">The <see cref="T:System.Net.HttpWebRequest" /> that creates the response.</param>
      <returns>A singleton observable containing the response.</returns>
      <requires>request != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;HttpWebResponse&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.IPairedObservable`2">
      <summary>
            Represents an observable with two notification channels for values.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
    </member>
    <member name="M:System.Reactive.IPairedObservable`2.Subscribe(System.Reactive.IPairedObserver{`0,`1})">
      <summary>
            Notifies the observable that an observer is to receive notifications.
            </summary>
      <param name="observer">The object that is to receive notifications.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <requires>observer != null</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.AnonymousPairedObservable`2.#ctor(System.IObservable{System.Either{`0,`1}})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.AnonymousPairedObservable`2" /> class.
            </summary>
      <param name="observable">The observable that receives subscriptions.</param>
      <requires>observable != null</requires>
    </member>
    <member name="T:System.Reactive.IPairedObserver`2">
      <summary>
            Provides a mechanism for receiving push-based notifications from an <see cref="T:System.Reactive.IPairedObservable`2" />.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
    </member>
    <member name="M:System.Reactive.IPairedObserver`2.OnNextLeft(`0)">
      <summary>
            Notifies left observers of a new value in the sequence.
            </summary>
      <param name="left">The current left notification information.</param>
    </member>
    <member name="M:System.Reactive.IPairedObserver`2.OnNextRight(`1)">
      <summary>
            Notifies right observers of a new value in the sequence.
            </summary>
      <param name="right">The current right notification information.</param>
    </member>
    <member name="M:System.Reactive.AnonymousPairedObserver`2.#ctor(System.IObserver{System.Either{`0,`1}})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.AnonymousPairedObserver`2" /> class.
            </summary>
      <param name="observer">The observer that receives notifications.</param>
      <requires>observer != null</requires>
    </member>
    <member name="T:System.Reactive.Disposables.SerialDisposableExtensions">
      <summary>
            Provides extension methods for <see cref="T:System.Reactive.Disposables.SerialDisposable" />.
            </summary>
    </member>
    <member name="M:System.Reactive.Disposables.SerialDisposableExtensions.SetDisposableIndirectly(System.Reactive.Disposables.SerialDisposable,System.Func{System.IDisposable})">
      <summary>
            Uses the double-indirection pattern to assign the disposable returned by the specified <paramref name="factory" />
            to the <see cref="P:System.Reactive.Disposables.SerialDisposable.Disposable" /> property of the specified <paramref name="disposable" />.
            </summary>
      <remarks>
            The double-indirection pattern avoids a race condition that can occur when the <paramref name="factory" /> 
            has a side-effect that causes the <see cref="P:System.Reactive.Disposables.SerialDisposable.Disposable" /> property of the specified 
            <paramref name="disposable" /> to be assigned before the <paramref name="factory" /> returns its disposable.
            This pattern ensures that the disposable returned by the <paramref name="factory" /> does not replace the 
            disposable that was assigned by the <paramref name="factory" />.
            </remarks>
      <param name="disposable">The object to which the disposable returned by the specified <paramref name="factory" /> is assigned.</param>
      <param name="factory">Returns an <see cref="T:System.IDisposable" /> that is assigned to the specified <paramref name="disposable" />.</param>
      <seealso href="http://social.msdn.microsoft.com/Forums/en-IE/rx/thread/4e15feae-9c4c-4962-af32-95dde1420dda#4d5fe8c8-e5e8-4ee7-93ca-b48b6a56b8af">
            Double indirection pattern example in Rx
            </seealso>
      <requires>disposable != null</requires>
      <requires>factory != null</requires>
    </member>
    <member name="T:System.Reactive.Linq.Observable2">
      <summary>
            Provides a set of <see langword="static" /> methods for query operations over observable sequences.
            </summary>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}})">
      <summary>
            Concurrently invokes the specified factory to create observables as fast and often as possible and subscribes to all of them
            up to the default maximum concurrency.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="sourceFactory">A function that returns observables.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}})" /> is similar to <see cref="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}},System.Int32)" />
            except that it does not obey the serializability guarantee for <see cref="M:System.IObserver`1.OnNext(`0)" /> that is recommended in the 
            <strong>Rx Design Guidelines</strong>.  Its behavior is therefore more suitable for hosting environments that must service multiple
            requests concurrently without blocking during observations.  This comes with the loss of automatic synchronization and thread-safety 
            that is normally provided by Rx operators, thus consumers are responsible for ensuring the thread-safety of all observers themselves.
            </para>
      </remarks>
      <returns>A concurrent observable sequence.</returns>
      <requires>sourceFactory != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Func{System.Exception,System.Boolean})">
      <summary>
            Concurrently invokes the specified factory to create observables as fast and often as possible and subscribes to all of them
            up to the default maximum concurrency.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="sourceFactory">A function that returns observables.</param>
      <param name="onError">Determines whether an error should fault the entire observable sequence.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Func{System.Exception,System.Boolean})" /> is similar to <see cref="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}},System.Int32)" />
            except that it does not obey the serializability guarantee for <see cref="M:System.IObserver`1.OnNext(`0)" /> that is recommended in the 
            <strong>Rx Design Guidelines</strong>.  Its behavior is therefore more suitable for hosting environments that must service multiple
            requests concurrently without blocking during observations.  This comes with the loss of automatic synchronization and thread-safety 
            that is normally provided by Rx operators, thus consumers are responsible for ensuring the thread-safety of all observers themselves.
            </para>
        <para>
            Furthermore, <see cref="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Func{System.Exception,System.Boolean})" /> provides an <paramref name="onError" /> parameter that 
            allows the caller to decide whether an <see cref="T:System.Exception" /> is fatal and should fault the entire sequence.  This function 
            should return <see langword="true" /> to indicate that an <see cref="T:System.Exception" /> has been handled, thus preventing the sequence
            from being faulted; otherwise, return <see langword="false" /> to fault the sequence and halt processing as soon as possible.
            In the latter case, the <see cref="T:System.Exception" /> is then passed to the observer of the sequence as is the normal behavior in Rx.
            </para>
      </remarks>
      <returns>A concurrent observable sequence.</returns>
      <requires>sourceFactory != null</requires>
      <requires>onError != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Int32)">
      <summary>
            Concurrently invokes the specified factory to create observables as fast and often as possible and subscribes to all of them
            up to the specified maximum concurrency.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="sourceFactory">A function that returns observables.</param>
      <param name="maxConcurrent">The maximum number of observables to be subscribed simultaneously.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Int32)" /> is similar to <see cref="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}},System.Int32)" />
            except that it does not obey the serializability guarantee for <see cref="M:System.IObserver`1.OnNext(`0)" /> that is recommended in the 
            <strong>Rx Design Guidelines</strong>.  Its behavior is therefore more suitable for hosting environments that must service multiple
            requests concurrently without blocking during observations.  This comes with the loss of automatic synchronization and thread-safety 
            that is normally provided by Rx operators, thus consumers are responsible for ensuring the thread-safety of all observers themselves.
            </para>
      </remarks>
      <returns>A concurrent observable sequence.</returns>
      <requires>sourceFactory != null</requires>
      <requires>maxConcurrent &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Int32,System.Func{System.Exception,System.Boolean})">
      <summary>
            Concurrently invokes the specified factory to create observables as fast and often as possible and subscribes to all of them
            up to the specified maximum concurrency.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="sourceFactory">A function that returns observables.</param>
      <param name="maxConcurrent">The maximum number of observables to be subscribed simultaneously.</param>
      <param name="onError">Determines whether an error should fault the entire observable sequence.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Int32,System.Func{System.Exception,System.Boolean})" /> is similar to <see cref="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}},System.Int32)" />
            except that it does not obey the serializability guarantee for <see cref="M:System.IObserver`1.OnNext(`0)" /> that is recommended in the 
            <strong>Rx Design Guidelines</strong>.  Its behavior is therefore more suitable for hosting environments that must service multiple
            requests concurrently without blocking during observations.  This comes with the loss of automatic synchronization and thread-safety 
            that is normally provided by Rx operators, thus consumers are responsible for ensuring the thread-safety of all observers themselves.
            </para>
        <para>
            Furthermore, <see cref="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Int32,System.Func{System.Exception,System.Boolean})" /> provides an <paramref name="onError" /> parameter that 
            allows the caller to decide whether an <see cref="T:System.Exception" /> is fatal and should fault the entire sequence.  This function 
            should return <see langword="true" /> to indicate that an <see cref="T:System.Exception" /> has been handled, thus preventing the sequence
            from being faulted; otherwise, return <see langword="false" /> to fault the sequence and halt processing as soon as possible.
            In the latter case, the <see cref="T:System.Exception" /> is then passed to the observer of the sequence as is the normal behavior in Rx.
            </para>
      </remarks>
      <returns>A concurrent observable sequence.</returns>
      <requires>sourceFactory != null</requires>
      <requires>maxConcurrent &gt; 0</requires>
      <requires>onError != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Catch``2(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
      <summary>
            Moves to the next observable sequence when the current sequence throws the specified type of exception 
            until one of the observables successfully terminates.  The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Catch``2(System.Collections.Generic.IEnumerable{System.IObservable{``0}},System.Func{``1,System.TimeSpan})">
      <summary>
            Moves to the next observable sequence when the current sequence throws the specified type of exception 
            using the specified back-off algorithm until one of the observables successfully terminates.
            The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <param name="backOffSelector">Selects the amount of time to delay before moving to the next observable 
            when the current sequence has faulted.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <requires>backOffSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Catch``2(System.Collections.Generic.IEnumerator{System.IObservable{``0}})">
      <summary>
            Moves to the next observable sequence when the current sequence throws the specified type of exception 
            until one of the observables successfully terminates.  The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Catch``2(System.Collections.Generic.IEnumerator{System.IObservable{``0}},System.Func{``1,System.Collections.Generic.IEnumerator{System.IObservable{``0}}})">
      <summary>
            Moves to the next observable sequence provided by the specified <paramref name="handler" /> when the current 
            sequence throws the specified type of exception until one of the observables successfully terminates.
            The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <param name="handler">Selects the next enumerator when an observable from the current enumerator has faulted.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <requires>handler != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Catch``2(System.Collections.Generic.IEnumerator{System.IObservable{``0}},System.Func{``1,System.Collections.Generic.IEnumerator{System.IObservable{``0}}},System.Func{``1,System.TimeSpan})">
      <summary>
            Moves to the next observable sequence provided by the specified <paramref name="handler" /> when the current 
            sequence throws the specified type of exception using the specified back-off algorithm until one of the observables 
            successfully terminates.  The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <param name="handler">Selects the next enumerator when an observable from the current enumerator has faulted.</param>
      <param name="backOffSelector">Selects the amount of time to delay before moving to the next observable 
            when the current sequence has faulted.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <requires>handler != null</requires>
      <requires>backOffSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.OnErrorResumeNext``2(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
      <summary>
            Moves to the next observable sequence when the current sequence throws the specified type of exception.
            The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.OnErrorResumeNext``2(System.Collections.Generic.IEnumerable{System.IObservable{``0}},System.Func{``1,System.TimeSpan})">
      <summary>
            Moves to the next observable sequence when the current sequence throws the specified type of exception 
            using the specified back-off algorithm.  The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <param name="backOffSelector">Selects the amount of time to delay before moving to the next observable 
            when the current sequence has faulted.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <requires>backOffSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.OnErrorResumeNext``2(System.Collections.Generic.IEnumerator{System.IObservable{``0}})">
      <summary>
            Moves to the next observable sequence when the current sequence throws the specified type of exception.
            The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.OnErrorResumeNext``2(System.Collections.Generic.IEnumerator{System.IObservable{``0}},System.Func{``1,System.Collections.Generic.IEnumerator{System.IObservable{``0}}})">
      <summary>
            Moves to the next observable sequence provided by the specified <paramref name="handler" /> when the current 
            sequence throws the specified type of exception.  The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <param name="handler">Selects the next enumerator when an observable from the current enumerator has faulted.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <requires>handler != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.OnErrorResumeNext``2(System.Collections.Generic.IEnumerator{System.IObservable{``0}},System.Func{``1,System.Collections.Generic.IEnumerator{System.IObservable{``0}}},System.Func{``1,System.TimeSpan})">
      <summary>
            Moves to the next observable sequence provided by the specified <paramref name="handler" /> when the current 
            sequence throws the specified type of exception using the specified back-off algorithm.
            The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <param name="handler">Selects the next enumerator when an observable from the current enumerator has faulted.</param>
      <param name="backOffSelector">Selects the amount of time to delay before moving to the next observable 
            when the current sequence has faulted.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <requires>handler != null</requires>
      <requires>backOffSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Retry``2(System.IObservable{``0},System.Int32)">
      <summary>
            Repeats the source observable sequence when it throws the specified type of exception 
            until it successfully terminates or the specified count has been reached and pairs it
            with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="source">The observable to be repeated.</param>
      <param name="retryCount">The maximum number of times to retry the sequence when it's faulted.</param>
      <returns>The specified observable sequence with an error channel.</returns>
      <requires>source != null</requires>
      <requires>retryCount &gt;= 0</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Retry``1(System.IObservable{``0},System.Int32,System.Func{System.Exception,System.Int32,System.TimeSpan})">
      <summary>
            Repeats the source observable sequence using the specified back-off algorithm until it 
            successfully terminates or the specified count has been reached and pairs it with an 
            error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be repeated.</param>
      <param name="retryCount">The maximum number of times to retry the sequence when it's faulted.</param>
      <param name="backOffSelector">Selects the amount of time to delay before repeating when the sequence has faulted.</param>
      <returns>The specified observable sequence with an error channel.</returns>
      <requires>source != null</requires>
      <requires>retryCount &gt;= 0</requires>
      <requires>backOffSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, Exception&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Retry``2(System.IObservable{``0},System.Int32,System.Func{``1,System.Int32,System.TimeSpan})">
      <summary>
            Repeats the source observable sequence when it throws the specified type of exception
            using the specified back-off algorithm until it successfully terminates or the specified 
            count has been reached and pairs it with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="source">The observable to be repeated.</param>
      <param name="retryCount">The maximum number of times to retry the sequence when it's faulted.</param>
      <param name="backOffSelector">Selects the amount of time to delay before repeating when the sequence has faulted.</param>
      <returns>The specified observable sequence with an error channel.</returns>
      <requires>source != null</requires>
      <requires>retryCount &gt;= 0</requires>
      <requires>backOffSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.RetryConsecutive``1(System.IObservable{``0},System.Int32)">
      <summary>
            Repeats the source observable sequence when it throws consecutively 
            until it produces a value, successfully terminates or the specified count 
            has been reached and pairs it with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be repeated.</param>
      <param name="consecutiveRetryCount">The maximum number of times to retry the sequence consecutively 
            when it's faulted.</param>
      <remarks>
        <see cref="M:System.Reactive.Linq.Observable2.RetryConsecutive``1(System.IObservable{``0},System.Int32)" /> is appropriate when permanent recovery is required for sequences 
            that experience ephemeral consecutive errors at unpredictable intervals, such as those originating 
            from network streams.  For example, it can produce a sequence that automatically reconnects upon 
            consecutive network failures up to the specified <paramref name="consecutiveRetryCount" /> number of 
            times; furthermore, if the sequence is able to successfully generate a value after an error, then 
            the retry count is reset for subsequent consecutive failures.
            </remarks>
      <returns>The specified observable sequence with an error channel.</returns>
      <requires>source != null</requires>
      <requires>consecutiveRetryCount &gt;= 0</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, Exception&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.RetryConsecutive``2(System.IObservable{``0},System.Int32)">
      <summary>
            Repeats the source observable sequence when it throws the specified type of exception 
            consecutively until it produces a value, successfully terminates or the specified count 
            has been reached and pairs it with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="source">The observable to be repeated.</param>
      <param name="consecutiveRetryCount">The maximum number of times to retry the sequence consecutively 
            when it's faulted.</param>
      <remarks>
        <see cref="M:System.Reactive.Linq.Observable2.RetryConsecutive``2(System.IObservable{``0},System.Int32)" /> is appropriate when permanent recovery is required for sequences 
            that experience ephemeral consecutive errors at unpredictable intervals, such as those originating 
            from network streams.  For example, it can produce a sequence that automatically reconnects upon 
            consecutive network failures up to the specified <paramref name="consecutiveRetryCount" /> number of 
            times; furthermore, if the sequence is able to successfully generate a value after an error, then 
            the retry count is reset for subsequent consecutive failures.
            </remarks>
      <returns>The specified observable sequence with an error channel.</returns>
      <requires>source != null</requires>
      <requires>consecutiveRetryCount &gt;= 0</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.RetryConsecutive``1(System.IObservable{``0},System.Int32,System.Func{System.Exception,System.Int32,System.TimeSpan})">
      <summary>
            Repeats the source observable sequence when it throws consecutively 
            using the specified back-off algorithm until it produces a value, successfully terminates or 
            the specified count has been reached and pairs it with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be repeated.</param>
      <param name="consecutiveRetryCount">The maximum number of times to retry the sequence consecutively 
            when it's faulted.</param>
      <param name="backOffSelector">Selects the amount of time to delay before repeating when the sequence has faulted.</param>
      <remarks>
        <see cref="M:System.Reactive.Linq.Observable2.RetryConsecutive``1(System.IObservable{``0},System.Int32,System.Func{System.Exception,System.Int32,System.TimeSpan})" /> is appropriate when permanent recovery is required for sequences 
            that experience ephemeral consecutive errors at unpredictable intervals, such as those originating 
            from network streams.  For example, it can produce a sequence that automatically reconnects upon 
            consecutive network failures up to the specified <paramref name="consecutiveRetryCount" /> number of 
            times; furthermore, if the sequence is able to successfully generate a value after an error, then 
            the retry count is reset for subsequent consecutive failures.
            </remarks>
      <returns>The specified observable sequence with an error channel.</returns>
      <seealso href="http://en.wikipedia.org/wiki/Exponential_backoff">
            Exponential backoff
            </seealso>
      <requires>source != null</requires>
      <requires>consecutiveRetryCount &gt;= 0</requires>
      <requires>backOffSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, Exception&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.RetryConsecutive``2(System.IObservable{``0},System.Int32,System.Func{``1,System.Int32,System.TimeSpan})">
      <summary>
            Repeats the source observable sequence when it throws the specified type of exception 
            consecutively using the specified back-off algorithm until it produces a value, successfully terminates 
            or the specified count has been reached and pairs it with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="source">The observable to be repeated.</param>
      <param name="consecutiveRetryCount">The maximum number of times to retry the sequence consecutively 
            when it's faulted.</param>
      <param name="backOffSelector">Selects the amount of time to delay before repeating when the sequence has faulted.</param>s
            <remarks><see cref="M:System.Reactive.Linq.Observable2.RetryConsecutive``2(System.IObservable{``0},System.Int32,System.Func{``1,System.Int32,System.TimeSpan})" /> is appropriate when permanent recovery is required for sequences 
            that experience ephemeral consecutive errors at unpredictable intervals, such as those originating 
            from network streams.  For example, it can produce a sequence that automatically reconnects upon 
            consecutive network failures up to the specified <paramref name="consecutiveRetryCount" /> number of 
            times; furthermore, if the sequence is able to successfully generate a value after an error, then 
            the retry count is reset for subsequent consecutive failures.
            </remarks><returns>The specified observable sequence with an error channel.</returns><seealso href="http://en.wikipedia.org/wiki/Exponential_backoff">
            Exponential backoff
            </seealso><requires>source != null</requires><requires>consecutiveRetryCount &gt;= 0</requires><requires>backOffSelector != null</requires><ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures></member>
    <member name="M:System.Reactive.Linq.Observable2.FromEventBasedAsyncPattern``1(System.Func{System.EventHandler{System.ComponentModel.AsyncCompletedEventArgs},``0},System.Action{``0},System.Action{``0},System.Action{System.Object},System.Action)">
      <summary>
            Creates an observable sequence that contains the cached result from an 
            Event-based Asynchronous Pattern (EBAP) implementation.
            </summary>
      <typeparam name="TDelegate">Type of the event's delegate.</typeparam>
      <param name="conversion">A function used to convert the given event handler to a delegate compatible
            with the underlying .NET event. The resulting delegate is used in calls to the 
            <paramref name="addHandler" /> and <paramref name="removeHandler" /> action parameters.</param>
      <param name="addHandler">Action that attaches the given event handler to the underlying .NET event.</param>
      <param name="removeHandler">Action that detaches the given event handler from the underlying .NET event.</param>
      <param name="start">An action that receives the user token object and begins the asynchronous process.</param>
      <param name="cancel">An action that cancels the asynchronous process when any subscription to the returned 
            observable is disposed.</param>
      <returns>An observable sequence that contains the cached result of the asynchronous operation.</returns>
      <seealso href="http://msdn.microsoft.com/en-us/library/wewwczdw.aspx">
            Event-based Asynchronous Pattern Overview
            </seealso>
      <requires>conversion != null</requires>
      <requires>addHandler != null</requires>
      <requires>removeHandler != null</requires>
      <requires>start != null</requires>
      <requires>cancel != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;AsyncCompletedEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.FromEventBasedAsyncPattern``2(System.Func{System.EventHandler{``1},``0},System.Action{``0},System.Action{``0},System.Action{System.Object},System.Action)">
      <summary>
            Creates an observable sequence that contains the cached result from an 
            Event-based Asynchronous Pattern (EBAP) implementation.
            </summary>
      <typeparam name="TDelegate">Type of the event's delegate.</typeparam>
      <typeparam name="TEventArgs">Type of the event's arguments.</typeparam>
      <param name="conversion">A function used to convert the given event handler to a delegate compatible
            with the underlying .NET event. The resulting delegate is used in calls to the 
            <paramref name="addHandler" /> and <paramref name="removeHandler" /> action parameters.</param>
      <param name="addHandler">Action that attaches the given event handler to the underlying .NET event.</param>
      <param name="removeHandler">Action that detaches the given event handler from the underlying .NET event.</param>
      <param name="start">An action that receives the user token object and begins the asynchronous process.</param>
      <param name="cancel">An action that cancels the asynchronous process when any subscription to the returned 
            observable is disposed.</param>
      <returns>An observable sequence that contains the cached result of the asynchronous operation.</returns>
      <seealso href="http://msdn.microsoft.com/en-us/library/wewwczdw.aspx">
            Event-based Asynchronous Pattern Overview
            </seealso>
      <requires>conversion != null</requires>
      <requires>addHandler != null</requires>
      <requires>removeHandler != null</requires>
      <requires>start != null</requires>
      <requires>cancel != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;TEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.FromEventBasedAsyncPattern``3(System.Func{System.EventHandler{System.ComponentModel.AsyncCompletedEventArgs},``0},System.Action{``0},System.Action{``0},System.Func{System.EventHandler{``2},``1},System.Action{``1},System.Action{``1},System.Action{System.Object},System.Action)">
      <summary>
            Creates a paired observable sequence of progress notifications along with the cached result from an 
            Event-based Asynchronous Pattern (EBAP) implementation.
            </summary>
      <typeparam name="TDelegate">Type of the event's delegate.</typeparam>
      <typeparam name="TProgressDelegate">Type of the progress event's delegate.</typeparam>
      <typeparam name="TProgressEventArgs">Type of the progress event's arguments.</typeparam>
      <param name="conversion">A function used to convert the given event handler to a delegate compatible
            with the underlying .NET event. The resulting delegate is used in calls to the 
            <paramref name="addHandler" /> and <paramref name="removeHandler" /> action parameters.</param>
      <param name="addHandler">Action that attaches the given event handler to the underlying .NET event.</param>
      <param name="removeHandler">Action that detaches the given event handler from the underlying .NET event.</param>
      <param name="progressConversion">A function used to convert the given progress event handler to a delegate compatible
            with the underlying .NET progress event. The resulting delegate is used in calls to the 
            <paramref name="addProgressHandler" /> and <paramref name="removeProgressHandler" />  action parameters.</param>
      <param name="addProgressHandler">Action that attaches the given progress event handler to the underlying .NET progress event.</param>
      <param name="removeProgressHandler">Action that detaches the given progress event handler from the underlying .NET progress event.</param>
      <param name="start">An action that receives the user token object and begins the asynchronous process.</param>
      <param name="cancel">An action that cancels the asynchronous process when any subscription to the returned 
            observable is disposed.</param>
      <returns>A paired observable sequence of progress notifications on the left and the cached result on the right.</returns>
      <seealso href="http://msdn.microsoft.com/en-us/library/wewwczdw.aspx">
            Event-based Asynchronous Pattern Overview
            </seealso>
      <requires>conversion != null</requires>
      <requires>addHandler != null</requires>
      <requires>removeHandler != null</requires>
      <requires>progressConversion != null</requires>
      <requires>addProgressHandler != null</requires>
      <requires>removeProgressHandler != null</requires>
      <requires>start != null</requires>
      <requires>cancel != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;EventPattern&lt;TProgressEventArgs&gt;, EventPattern&lt;AsyncCompletedEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.FromEventBasedAsyncPattern``4(System.Func{System.EventHandler{``1},``0},System.Action{``0},System.Action{``0},System.Func{System.EventHandler{``3},``2},System.Action{``2},System.Action{``2},System.Action{System.Object},System.Action)">
      <summary>
            Creates a paired observable sequence of progress notifications along with the cached result from an 
            Event-based Asynchronous Pattern (EBAP) implementation.
            </summary>
      <typeparam name="TDelegate">Type of the event's delegate.</typeparam>
      <typeparam name="TEventArgs">Type of the event's arguments.</typeparam>
      <typeparam name="TProgressDelegate">Type of the progress event's delegate.</typeparam>
      <typeparam name="TProgressEventArgs">Type of the progress event's arguments.</typeparam>
      <param name="conversion">A function used to convert the given event handler to a delegate compatible
            with the underlying .NET event. The resulting delegate is used in calls to the 
            <paramref name="addHandler" /> and <paramref name="removeHandler" /> action parameters.</param>
      <param name="addHandler">Action that attaches the given event handler to the underlying .NET event.</param>
      <param name="removeHandler">Action that detaches the given event handler from the underlying .NET event.</param>
      <param name="progressConversion">A function used to convert the given progress event handler to a delegate compatible
            with the underlying .NET progress event. The resulting delegate is used in calls to the 
            <paramref name="addProgressHandler" /> and <paramref name="removeProgressHandler" />  action parameters.</param>
      <param name="addProgressHandler">Action that attaches the given progress event handler to the underlying .NET progress event.</param>
      <param name="removeProgressHandler">Action that detaches the given progress event handler from the underlying .NET progress event.</param>
      <param name="start">An action that receives the user token object and begins the asynchronous process.</param>
      <param name="cancel">An action that cancels the asynchronous process when any subscription to the returned 
            observable is disposed.</param>
      <returns>A paired observable sequence of progress notifications on the left and the cached result on the right.</returns>
      <seealso href="http://msdn.microsoft.com/en-us/library/wewwczdw.aspx">
            Event-based Asynchronous Pattern Overview
            </seealso>
      <requires>conversion != null</requires>
      <requires>addHandler != null</requires>
      <requires>removeHandler != null</requires>
      <requires>progressConversion != null</requires>
      <requires>addProgressHandler != null</requires>
      <requires>removeProgressHandler != null</requires>
      <requires>start != null</requires>
      <requires>cancel != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;EventPattern&lt;TProgressEventArgs&gt;, EventPattern&lt;TEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.FromPropertyChangedPattern``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>
            Creates an observable sequence of property changed notifications for the specified 
            <paramref name="property" /> on the specified <paramref name="source" />.
            </summary>
      <typeparam name="TSource">Type of the object that defines the specified <paramref name="property" />.</typeparam>
      <typeparam name="TValue">Type of the property's value.</typeparam>
      <param name="source">The object that defines the specified <paramref name="property" />.</param>
      <param name="property">The property on the specified <paramref name="source" /> from which to generate property changed notifications.</param>
      <remarks>
            The following property changed notification patterns are supported: 
            <list type="bullet"><item><see cref="T:System.ComponentModel.INotifyPropertyChanged" /> implementations.</item><item>[Property]Changed event pattern.</item><item>WPF dependency properties.</item></list></remarks>
      <returns>An observable sequence of property changed notifications.</returns>
      <requires>source != null</requires>
      <requires>property != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Introspect``1(System.IObservable{``0})">
      <summary>
            Pairs the specified observable sequence with an observable for each value that indicates 
            the duration of the observation of that value.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable sequence to introspect.</param>
      <returns>A paired observable with the left channel providing introspection windows and the 
            right channel providing values from the specified observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;IObservable&lt;TSource&gt;, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Introspect``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Pairs the specified observable sequence with an observable for each value that indicates 
            the duration of the observation of that value.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable sequence to introspect.</param>
      <param name="scheduler">Schedules the observations of values in the right notification channel.</param>
      <returns>A paired observable with the left channel providing introspection windows and the 
            right channel providing values from the specified observable.</returns>
      <requires>source != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;IObservable&lt;TSource&gt;, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.WindowIntrospective``1(System.IObservable{``0})">
      <summary>
            Generates a sequence of windows where each window contains all values that were observed from 
            the <paramref name="source" /> while the values in the previous window were being observed.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable sequence from which to create introspection windows.</param>
      <returns>The source observable sequence buffered into introspection windows.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IObservable&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.WindowIntrospective``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Generates a sequence of windows where each window contains all values that were observed from 
            the <paramref name="source" /> while the values in the previous window were being observed.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable sequence from which to create introspection windows.</param>
      <param name="scheduler">Schedules when windows are observed as well as the values in each window.</param>
      <returns>The source observable sequence buffered into introspection windows.</returns>
      <requires>source != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IObservable&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.BufferIntrospective``1(System.IObservable{``0})">
      <summary>
            Generates a sequence of lists where each list contains all values that were observed from 
            the <paramref name="source" /> while the previous list was being observed.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable sequence from which to create introspection lists.</param>
      <returns>The source observable sequence buffered into introspection lists.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IList&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.BufferIntrospective``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Generates a sequence of lists where each list contains all values that were observed from 
            the <paramref name="source" /> while the previous list was being observed.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable sequence from which to create introspection lists.</param>
      <param name="scheduler">Schedules when lists are observed.</param>
      <returns>The source observable sequence buffered into introspection lists.</returns>
      <requires>source != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IList&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Maybe``1(System.IObservable{``0})">
      <summary>
            Returns the elements of the specified sequence as a sequence of <see cref="T:System.Maybe`1" />, 
            starting with <see cref="M:System.Maybe.Empty``1" />.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be projected into <see cref="T:System.Maybe`1" /> values.</param>
      <returns>A sequence m <see cref="T:System.Maybe`1" /> values that contain the values from the specified
            observable, starting with <see cref="M:System.Maybe.Empty``1" />.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Maybe&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Multicast``2(System.IObservable{``0},System.Func{System.Reactive.Subjects.ISubject{``0,``1}})">
      <summary>
            Returns a connectable observable sequence that upon connection causes the <paramref name="source" /> sequence to 
            push results into a new fresh subject, which is created by invoking the specified <paramref name="factory" /> function 
            each time that a connection is disposed and a new connection is made.
            </summary>
      <typeparam name="TSource">The type of the source.</typeparam>
      <typeparam name="TResult">The type of the result.</typeparam>
      <param name="source">The source sequence whose elements will be pushed into the specified subject.</param>
      <param name="factory">The factory function used to create the subject that notifications will be pushed into.</param>
      <returns>A connectable observable sequence that upon connection causes the source sequence to push results into a new subject.</returns>
      <requires>source != null</requires>
      <requires>factory != null</requires>
      <ensures>Contract.Result&lt;IConnectableObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.AsPairedObservable``2(System.IObservable{System.Either{``0,``1}})">
      <summary>
            Converts the specified observable sequence of <see cref="T:System.Either`2" /> into
            an <see cref="T:System.Reactive.IPairedObservable`2" />.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable sequence to convert.</param>
      <returns>The specified observable sequence as a paired observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Pair``2(System.IObservable{``0},System.Func{``0,``1})">
      <summary>
            Creates a paired observable from the specified observable sequence and selector function.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="leftSource">The observable sequence that provides notifications for the left channel.</param>
      <param name="rightSelector">Selects a value for the right channel from each value in the specified observable sequence.</param>
      <returns>The specified observable sequence paired with the values produced by the selector.</returns>
      <requires>leftSource != null</requires>
      <requires>rightSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Pair``2(System.IObservable{``0},System.IObservable{``1})">
      <summary>
            Creates a paired observable by combining the latest values of the specified observable sequences.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="leftSource">The observable sequence that provides notifications for the left channel.</param>
      <param name="rightSource">The observable sequence that provides notifications for the right channel.</param>
      <returns>The latest vlaues of both observable sequences paired together.</returns>
      <requires>leftSource != null</requires>
      <requires>rightSource != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Pair``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,``1,System.Reactive.Linq.PairDirection})">
      <summary>
            Creates a paired observable by combining the latest values of the specified observable sequences
            and choosing which channels will receive values based on the specified selector.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="leftSource">The observable sequence that provides notifications for the left channel.</param>
      <param name="rightSource">The observable sequence that provides notifications for the right channel.</param>
      <param name="directionSelector">Selects the channels that will receive notifications for every pair.</param>
      <returns>The specified observable sequences paired together and modified by the specified selector.</returns>
      <requires>leftSource != null</requires>
      <requires>rightSource != null</requires>
      <requires>directionSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Pair``1(System.IObservable{``0},System.Func{``0,System.Reactive.Linq.PairDirection})">
      <summary>
            Creates a paired observable from the specified observable sequence by choosing which channels 
            will receive each value based on the specified selector function.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable from which values will be paired based on the specified selector function.</param>
      <param name="directionSelector">Selects the channels that will receive notifications for every value in the <paramref name="source" />.</param>
      <returns>A paired observable sequence projected from the specified observable sequence based on the specified selector function.</returns>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Prime``1(System.Reactive.Subjects.IConnectableObservable{``0})">
      <summary>
            Connects the specified connectable observable sequence upon the first subscription and never disconnects.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The connectable observable sequence to be connected upon the first subscription.</param>
      <remarks>
        <para>
            It may be easier to think of priming as creating a warm observable, instead of a cold or hot observable.
            A cold observable allows subscription side-effects to occur each time, whereas a hot observable does not.
            A hot observable is already active before the first subscription, whereas a warm observable is not.
            </para>
      </remarks>
      <returns>The specified observable sequence primed for use.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Prime``1(System.Reactive.Subjects.IConnectableObservable{``0},System.Action{System.IDisposable})">
      <summary>
            Connects the specified connectable observable sequence upon the first subscription and provides 
            the ability to disconnect to a callback.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The connectable observable sequence to be connected upon the first subscription.</param>
      <param name="whenConnected">Receives the subscription each time the observable is connected.</param>
      <remarks>
        <para>
            It may be easier to think of priming as creating a warm observable, instead of a cold or hot observable.
            A cold observable allows subscription side-effects to occur each time, whereas a hot observable does not.
            A hot observable is already active before the first subscription, whereas a warm observable is not.
            </para>
      </remarks>
      <returns>The specified observable sequence primed for use.</returns>
      <requires>source != null</requires>
      <requires>whenConnected != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.StartPrimed(System.Action)">
      <summary>
            Invokes the specified <paramref name="action" /> asynchronously upon the first subscription to the returned observable.
            </summary>
      <param name="action">The action to be invoked upon the first subscription.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.StartPrimed(System.Action)" /> differs from <see cref="M:System.Reactive.Linq.Observable.Start(System.Action)" /> in that the former
            does not call the action until the first subscription, although the observable remains hot for subsequent 
            subscriptions.
            </para>
        <para>
            It may be easier to think of priming as creating a warm observable, instead of a cold or hot observable.
            A cold observable allows subscription side-effects to occur each time, whereas a hot observable does not.
            A hot observable is already active before the first subscription, whereas a warm observable is not.
            </para>
      </remarks>
      <returns>An observable sequence primed to call the specified <paramref name="action" /> upon the first subscription.</returns>
      <requires>action != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Unit&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.StartPrimed(System.Action,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Invokes the specified <paramref name="action" /> asynchronously upon the first subscription to the returned observable.
            </summary>
      <param name="action">The action to be invoked upon the first subscription.</param>
      <param name="scheduler">Schedules the call to the action.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.StartPrimed(System.Action)" /> differs from <see cref="M:System.Reactive.Linq.Observable.Start(System.Action)" /> in that the former
            does not call the action until the first subscription, although the observable remains hot for subsequent 
            subscriptions.
            </para>
        <para>
            It may be easier to think of priming as creating a warm observable, instead of a cold or hot observable.
            A cold observable allows subscription side-effects to occur each time, whereas a hot observable does not.
            A hot observable is already active before the first subscription, whereas a warm observable is not.
            </para>
      </remarks>
      <returns>An observable sequence primed to call the specified <paramref name="action" /> upon the first subscription.</returns>
      <requires>action != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Unit&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.StartPrimed``1(System.Func{``0})">
      <summary>
            Invokes the specified <paramref name="function" /> asynchronously upon the first subscription to the returned observable.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="function">The function to be invoked upon the first subscription.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.StartPrimed``1(System.Func{``0})" /> differs from <see cref="M:System.Reactive.Linq.Observable.Start``1(System.Func{``0})" /> in that the former
            does not call the function until the first subscription, although the observable remains hot for subsequent 
            subscriptions.
            </para>
        <para>
            It may be easier to think of priming as creating a warm observable, instead of a cold or hot observable.
            A cold observable allows subscription side-effects to occur each time, whereas a hot observable does not.
            A hot observable is already active before the first subscription, whereas a warm observable is not.
            </para>
      </remarks>
      <returns>An observable sequence primed to call the specified <paramref name="function" /> upon the first subscription.</returns>
      <requires>function != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Unit&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.StartPrimed``1(System.Func{``0},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Invokes the specified <paramref name="function" /> asynchronously upon the first subscription to the returned observable.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="function">The function to be invoked upon the first subscription.</param>
      <param name="scheduler">Schedules the call to the function.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.StartPrimed``1(System.Func{``0})" /> differs from <see cref="M:System.Reactive.Linq.Observable.Start``1(System.Func{``0})" /> in that the former
            does not call the function until the first subscription, although the observable remains hot for subsequent 
            subscriptions.
            </para>
        <para>
            It may be easier to think of priming as creating a warm observable, instead of a cold or hot observable.
            A cold observable allows subscription side-effects to occur each time, whereas a hot observable does not.
            A hot observable is already active before the first subscription, whereas a warm observable is not.
            </para>
      </remarks>
      <returns>An observable sequence primed to call the specified <paramref name="function" /> upon the first subscription.</returns>
      <requires>function != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.AsInterval``1(System.IObservable{``0},System.TimeSpan)">
      <summary>
            Returns the elements of the specified sequence time-shifted to the specified minimum period
            between elements, starting with the specified minimum period.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be time-shifted.</param>
      <param name="minimumPeriod">The minimum amount of time to delay before the first element 
            and between elements.</param>
      <returns>The specified observable sequence time-shifted to the specified minimum period
            between elements, starting with the specified minimum period.</returns>
      <requires>source != null</requires>
      <requires>minimumPeriod &gt;= TimeSpan.Zero</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.AsInterval``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Returns the elements of the specified sequence time-shifted to the specified minimum period
            between elements, starting with the specified minimum period.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be time-shifted.</param>
      <param name="minimumPeriod">The minimum amount of time to delay before the first element 
            and between elements.</param>
      <param name="scheduler">An object used to schedule notifications.</param>
      <returns>The specified observable sequence time-shifted to the specified minimum period
            between elements, starting with the specified minimum period.</returns>
      <requires>source != null</requires>
      <requires>minimumPeriod &gt;= TimeSpan.Zero</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.AsTimer``1(System.IObservable{``0},System.TimeSpan)">
      <summary>
            Returns the elements of the specified sequence time-shifted to the specified minimum period
            between elements.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be time-shifted.</param>
      <param name="minimumPeriod">The minimum amount of time to delay between elements.</param>
      <returns>The specified observable sequence time-shifted to the specified minimum period
            between elements.</returns>
      <requires>source != null</requires>
      <requires>minimumPeriod &gt;= TimeSpan.Zero</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.AsTimer``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Returns the elements of the specified sequence time-shifted to the specified minimum period
            between elements.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be time-shifted.</param>
      <param name="minimumPeriod">The minimum amount of time to delay between elements.</param>
      <param name="scheduler">An object used to schedule notifications.</param>
      <returns>The specified observable sequence time-shifted to the specified minimum period
            between elements.</returns>
      <requires>source != null</requires>
      <requires>minimumPeriod &gt;= TimeSpan.Zero</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Pulse``1(System.IObservable{``0},System.TimeSpan)">
      <summary>
            Returns the elements of the specified sequence time-shifted to the specified <paramref name="period" />, 
            with the latest value repeated when the specified sequence is silent for longer than the specified 
            <paramref name="period" />.
            </summary>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Pulse``1(System.IObservable{``0},System.TimeSpan)" /> is similar to <see cref="M:System.Reactive.Linq.Observable2.AsTimer``1(System.IObservable{``0},System.TimeSpan)" />
            in that it begins without delaying as soon as the first value is observed; however, it differs in that the 
            <paramref name="period" /> between notifications is constant and the last value is repeated at the specified interval 
            while the observable is silent.
            </para>
        <alert type="tip">
            To achieve a pulse without duplicate values, pass the returned observable to Observable.DistinctUntilChanged.
            </alert>
      </remarks>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be time-shifted.</param>
      <param name="period">The exact amount of time to delay between elements.</param>
      <returns>The specified observable sequence time-shifted to the specified minimum period
            between elements, starting with the specified minimum period.</returns>
      <requires>source != null</requires>
      <requires>period &gt;= TimeSpan.Zero</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Pulse``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Returns the elements of the specified sequence time-shifted to the specified <paramref name="period" />, 
            with the latest value repeated when the specified sequence is silent for longer than the specified 
            <paramref name="period" />.
            </summary>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Pulse``1(System.IObservable{``0},System.TimeSpan)" /> is similar to <see cref="M:System.Reactive.Linq.Observable2.AsTimer``1(System.IObservable{``0},System.TimeSpan)" />
            in that it begins without delaying as soon as the first value is observed; however, it differs in that the 
            <paramref name="period" /> between notifications is constant and the last value is repeated at the specified interval 
            while the observable is silent.
            </para>
        <alert type="tip">
            To achieve a pulse without duplicate values, pass the returned observable to Observable.DistinctUntilChanged.
            </alert>
      </remarks>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be time-shifted.</param>
      <param name="period">The exact amount of time to delay between elements.</param>
      <param name="scheduler">An object used to schedule notifications.</param>
      <returns>The specified observable sequence time-shifted to the specified minimum period
            between elements, starting with the specified minimum period.</returns>
      <requires>source != null</requires>
      <requires>period &gt;= TimeSpan.Zero</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.TimeShift``2(System.IObservable{``0},System.Func{``0,System.IObservable{``1}})">
      <summary>
            Time-shifts each value in the specified observable sequence to a sequence returned by the specified selector
            and concatenates the timer sequences returned by the selector.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TTimer">Type of the timer notifications.</typeparam>
      <param name="source">The observable sequence to be time-shifted.</param>
      <param name="timeSelector">Selects an observable sequence that indicates when the current value should be pushed.</param>
      <returns>The specified observable sequence time-shifted to the concatenated timer sequences returned by the selector.</returns>
      <requires>source != null</requires>
      <requires>timeSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.TimeShift``2(System.IObservable{``0},System.IObservable{``1})">
      <summary>
            Time-shifts each value in the specified observable sequence to the specified <paramref name="timer" />.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TTimer">Type of the timer notifications.</typeparam>
      <param name="source">The observable sequence to be time-shifted.</param>
      <param name="timer">The observable sequence to which the values from the source sequence are time-shifted.</param>
      <returns>The specified observable sequence time-shifted to the specified <paramref name="timer" /> sequence.</returns>
      <requires>source != null</requires>
      <requires>timer != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Cast``2(System.IObservable{``0})">
      <summary>
            Converts the elements of an observable sequence to the specified type.
            </summary>
      <remarks>
            The existing <see cref="M:System.Reactive.Linq.Observable.Cast``1(System.IObservable{System.Object})" /> operator only works on observable sequences of <see cref="T:System.Object" />.
            In Windows Phone, since <see cref="T:System.IObservable`1" /> isn't covariant on <em>T</em>, sometimes casting is required between 
            strongly-typed sequences of data to work correctly with certain operators.  <see cref="M:System.Reactive.Linq.Observable2.Cast``2(System.IObservable{``0})" /> facilitates 
            this need.
            </remarks>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TResult">The type to which each object in the observable sequence is cast.</typeparam>
      <param name="source">The observable containing the values to be cast.</param>
      <returns>An observable sequence containing the elements of the source observable cast to the specified type.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.Linq.OperationalObservable">
      <summary>
            Provides extension methods that convert an <see cref="T:System.IObservable`1" /> into an <see cref="T:System.Reactive.OperationalObservable`2" />.
            </summary>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.SByte})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.SByte" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.SByte},System.Func{System.IObservable{System.SByte},System.IObservable{System.SByte},System.Func{System.SByte,System.SByte,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Byte" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.SByte},System.Func{System.IObservable{System.SByte},System.IObservable{System.SByte},System.Func{System.SByte,System.SByte,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.SByte" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Reactive.OperationalObservable`2" />.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Byte})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Byte" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Byte},System.Func{System.IObservable{System.Byte},System.IObservable{System.Byte},System.Func{System.Byte,System.Byte,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Byte" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Byte},System.Func{System.IObservable{System.Byte},System.IObservable{System.Byte},System.Func{System.Byte,System.Byte,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Byte" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Reactive.OperationalObservable`2" />.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Char})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Char" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Char},System.Func{System.IObservable{System.Char},System.IObservable{System.Char},System.Func{System.Char,System.Char,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Char" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Char},System.Func{System.IObservable{System.Char},System.IObservable{System.Char},System.Func{System.Char,System.Char,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Char" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Reactive.OperationalObservable`2" />.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int16})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Int16" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int16},System.Func{System.IObservable{System.Int16},System.IObservable{System.Int16},System.Func{System.Int16,System.Int16,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Int16" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int16},System.Func{System.IObservable{System.Int16},System.IObservable{System.Int16},System.Func{System.Int16,System.Int16,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Int16" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Reactive.OperationalObservable`2" />.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.UInt16})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.UInt16" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.UInt16},System.Func{System.IObservable{System.UInt16},System.IObservable{System.UInt16},System.Func{System.UInt16,System.UInt16,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.UInt16" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.UInt16},System.Func{System.IObservable{System.UInt16},System.IObservable{System.UInt16},System.Func{System.UInt16,System.UInt16,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.UInt16" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Reactive.OperationalObservable`2" />.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Int32" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Int32" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.UInt32})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.UInt32" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;uint&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.UInt32},System.Func{System.IObservable{System.UInt32},System.IObservable{System.UInt32},System.Func{System.UInt32,System.UInt32,System.UInt32},System.IObservable{System.UInt32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.UInt32" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;uint&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int64})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Int64" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;long&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int64},System.Func{System.IObservable{System.Int64},System.IObservable{System.Int64},System.Func{System.Int64,System.Int64,System.Int64},System.IObservable{System.Int64}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Int64" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;long&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.UInt64})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.UInt64" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;ulong&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.UInt64},System.Func{System.IObservable{System.UInt64},System.IObservable{System.UInt64},System.Func{System.UInt64,System.UInt64,System.UInt64},System.IObservable{System.UInt64}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.UInt64" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;ulong&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Single})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Single" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;float&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Single},System.Func{System.IObservable{System.Single},System.IObservable{System.Single},System.Func{System.Single,System.Single,System.Single},System.IObservable{System.Single}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Single" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;float&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Double})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Double" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;double&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Double},System.Func{System.IObservable{System.Double},System.IObservable{System.Double},System.Func{System.Double,System.Double,System.Double},System.IObservable{System.Double}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Double" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;double&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Decimal})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Decimal" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;decimal&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Decimal},System.Func{System.IObservable{System.Decimal},System.IObservable{System.Decimal},System.Func{System.Decimal,System.Decimal,System.Decimal},System.IObservable{System.Decimal}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Decimal" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;decimal&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational``1(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``0},System.Func{``0,``0,``0},System.IObservable{``0}},System.Func{``0,``0,``0},System.Func{``0,``0,``0},System.Func{``0,``0,``0},System.Func{``0,``0,``0},System.Func{``0,``0},System.Func{``0,``0})">
      <summary>
            Creates an <see cref="T:System.Reactive.OperationalObservable`1" /> for the specified <paramref name="source" /> from the specified operators.
            </summary>
      <typeparam name="T">The type of objects to observe.</typeparam>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="add">The addition operator.</param>
      <param name="subtract">The subtraction operator.</param>
      <param name="multiply">The multiplication operator.</param>
      <param name="divide">The division operator.</param>
      <param name="positive">The plus operator.</param>
      <param name="negative">The negation operator.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`1" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational``2(System.IObservable{``0},System.Func{System.IObservable{``1},System.Reactive.OperationalObservable{``1}},System.Func{System.IObservable{``0},System.IObservable{``0},System.Func{``0,``0,``1},System.IObservable{``1}},System.Func{``0,``0,``1},System.Func{``0,``0,``1},System.Func{``0,``0,``1},System.Func{``0,``0,``1},System.Func{``0,``1},System.Func{``0,``1})">
      <summary>
            Creates an <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <paramref name="source" /> from the specified operators.
            </summary>
      <typeparam name="TIn">The type of input to observe.</typeparam>
      <typeparam name="TOut">The type of output that each operation generates.</typeparam>
      <param name="source">The observable to be converted.</param>
      <param name="resultSelector">Projects the result sequence into an <see cref="T:System.Reactive.OperationalObservable`1" />.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="add">The addition operator.</param>
      <param name="subtract">The subtraction operator.</param>
      <param name="multiply">The multiplication operator.</param>
      <param name="divide">The division operator.</param>
      <param name="positive">The plus operator.</param>
      <param name="negative">The negation operator.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TIn, TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.Linq.PairDirection">
      <summary>
            Indicates whether an observed value being projected into an <see cref="T:System.Reactive.IPairedObservable`2" /> is a
            left value, right value, neither or both.
            </summary>
    </member>
    <member name="F:System.Reactive.Linq.PairDirection.Neither">
      <summary>
            The value is excluded.
            </summary>
    </member>
    <member name="F:System.Reactive.Linq.PairDirection.Left">
      <summary>
            The value is for the left channel.
            </summary>
    </member>
    <member name="F:System.Reactive.Linq.PairDirection.Right">
      <summary>
            The value is for the right channel.
            </summary>
    </member>
    <member name="F:System.Reactive.Linq.PairDirection.Both">
      <summary>
            Ths value is for both the left and right channels.
            </summary>
    </member>
    <member name="T:System.Reactive.Linq.PairedObservable">
      <summary>
            Provides extension and factory methods for <see cref="T:System.Reactive.IPairedObservable`2" />.
            </summary>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.Combine``3(System.IObservable{System.Either{``0,``1}},System.Func{``0,``1,``2})">
      <summary>
            Combines the latest values from both notification channels and projects the results into a new sequence.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <typeparam name="TResult">Type of the result.</typeparam>
      <param name="source">The observable from which values are combined.</param>
      <param name="selector">Combines values from both notification channels.</param>
      <remarks>
        <see cref="M:System.Reactive.Linq.PairedObservable.Combine``3(System.IObservable{System.Either{``0,``1}},System.Func{``0,``1,``2})" /> is similar to <see cref="M:System.Reactive.Linq.Observable.CombineLatest``3(System.IObservable{``0},System.IObservable{``1},System.Func{``0,``1,``2})" />.
            </remarks>
      <returns>An observable of results from the combination of the latest values in both notification channels.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.Create``2(System.Func{System.Reactive.IPairedObserver{``0,``1},System.Action})">
      <summary>
            Creates a paired observable sequence from the <paramref name="subscribe" /> implementation.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="subscribe">Subscribes observers to the paired observable.</param>
      <returns>A paired observable that calls the specified <paramref name="subscribe" /> function when an observer subscribes.</returns>
      <requires>subscribe != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.Create``2(System.Func{System.Reactive.IPairedObserver{``0,``1},System.IDisposable})">
      <summary>
            Creates a paired observable sequence from the <paramref name="subscribe" /> implementation.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="subscribe">Subscribes observers to the paired observable.</param>
      <returns>A paired observable that calls the specified <paramref name="subscribe" /> function when an observer subscribes.</returns>
      <requires>subscribe != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.ForEachPair``2(System.IObservable{System.Either{``0,``1}},System.Action{``0},System.Action{``1})">
      <summary>
            Invokes the actions for their side-effects on each value in the observable sequence and blocks till the sequence is terminated.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable for which a subscription is created.</param>
      <param name="onNextLeft">The handler of notifications in the left channel.</param>
      <param name="onNextRight">The handler of notifications in the right channel.</param>
      <requires>source != null</requires>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.Select``4(System.IObservable{System.Either{``0,``1}},System.Func{``0,``2},System.Func{``1,``3})">
      <summary>
            Projects the values from both notification channels into a new sequence.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <typeparam name="TLeftResult">Result type of the left notification channel.</typeparam>
      <typeparam name="TRightResult">Result type of the right notification channel.</typeparam>
      <param name="source">The observable from which values are projected.</param>
      <param name="leftSelector">Projects values from the left notification channel.</param>
      <param name="rightSelector">Projects value from the right notification channel.</param>
      <returns>A paired observable of results from the projection of values in both notification channels.</returns>
      <requires>source != null</requires>
      <requires>leftSelector != null</requires>
      <requires>rightSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeftResult, TRightResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.SelectLeft``3(System.IObservable{System.Either{``0,``1}},System.Func{``0,``2})">
      <summary>
            Projects the values from the left notification channel into a new sequence.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <typeparam name="TResult">Type of the result.</typeparam>
      <param name="source">The observable from which values are projected.</param>
      <param name="selector">Projects values from the left notification channel.</param>
      <returns>An observable of results from the projection of values in the left notification channel.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.SelectRight``3(System.IObservable{System.Either{``0,``1}},System.Func{``1,``2})">
      <summary>
            Projects the values from the right notification channel into a new sequence.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <typeparam name="TResult">Type of the result.</typeparam>
      <param name="source">The observable from which values are projected.</param>
      <param name="selector">Projects values from the right notification channel.</param>
      <returns>An observable of results from the projection of values in the right notification channel.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.TakeLeft``2(System.IObservable{System.Either{``0,``1}})">
      <summary>
            Returns an observable that contains only the values from the left notification channel.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable from which values are taken.</param>
      <returns>An observable of values from the left notification channel.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TLeft&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.TakeRight``2(System.IObservable{System.Either{``0,``1}})">
      <summary>
            Returns an observable that contains only the values from the right notification channel.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable from which values are taken.</param>
      <returns>An observable of values from the right notification channel.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.TakeLeft``2(System.IObservable{System.Either{``0,``1}},System.Int32)">
      <summary>
            Returns an observable that contains only the values from the left notification channel
            up to the specified <paramref name="count" />.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable from which values are taken.</param>
      <param name="count">The number of values to take.</param>
      <returns>An observable of values from the left notification channel.</returns>
      <requires>source != null</requires>
      <requires>count &gt;= 0</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.TakeRight``2(System.IObservable{System.Either{``0,``1}},System.Int32)">
      <summary>
            Returns an observable that contains only the values from the right notification channel
            up to the specified <paramref name="count" />.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable from which values are taken.</param>
      <param name="count">The number of values to take.</param>
      <returns>An observable of values from the right notification channel.</returns>
      <requires>source != null</requires>
      <requires>count &gt;= 0</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.OperationalObservable`2">
      <summary>
            Represents an observable that uses its unary and binary operator overloads as observable query operators.
            </summary>
      <typeparam name="TIn">Input type.</typeparam>
      <typeparam name="TOut">Output type.</typeparam>
      <invariant>source != null</invariant>
      <invariant>resultSelector != null</invariant>
      <invariant>binaryOperation != null</invariant>
      <invariant>add != null</invariant>
      <invariant>subtract != null</invariant>
      <invariant>multiply != null</invariant>
      <invariant>divide != null</invariant>
      <invariant>positive != null</invariant>
      <invariant>negative != null</invariant>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Subscribe(System.IObserver{`0})">
      <summary>
            Notifies the observable that an observer is to receive notifications.
            </summary>
      <param name="observer">The object that is to receive notifications.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Addition(System.Reactive.OperationalObservable{`0,`1},System.IObservable{`0})">
      <summary>
            Creates a new operational observable that adds the values in the specified observables 
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first observable.</param>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Add(System.IObservable{`0})">
      <summary>
            Creates a new operational observable that adds the values in this observable to the values in the specified observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Addition(System.Reactive.OperationalObservable{`0,`1},`0)">
      <summary>
            Creates a new operational observable that adds the values in the specified observable to the specified value
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The observable.</param>
      <param name="second">A value that is added to each value in the <paramref name="first" /> observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Add(`0)">
      <summary>
            Creates a new operational observable that adds the values in this observable to the specified <paramref name="value" />.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that is added to each value in this observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Subtraction(System.Reactive.OperationalObservable{`0,`1},System.IObservable{`0})">
      <summary>
            Creates a new operational observable that subtracts the values in the specified observables 
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first observable.</param>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Subtract(System.IObservable{`0})">
      <summary>
            Creates a new operational observable that subtracts the values in the specified observable from the values in this observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Subtraction(System.Reactive.OperationalObservable{`0,`1},`0)">
      <summary>
            Creates a new operational observable that subtracts the specified value from the values in the specified observable
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The observable.</param>
      <param name="second">A value that is subtracted from each value in the <paramref name="first" /> observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Subtract(`0)">
      <summary>
            Creates a new operational observable that subtracts the specified value from the values in this observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that is subtracted from each value in this observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Multiply(System.Reactive.OperationalObservable{`0,`1},System.IObservable{`0})">
      <summary>
            Creates a new operational observable that multiplies the values in the specified observables 
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first observable.</param>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Multiply(System.IObservable{`0})">
      <summary>
            Creates a new operational observable that multiplies the values in this observable with the values in the specified observable.
            </summary>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Multiply(System.Reactive.OperationalObservable{`0,`1},`0)">
      <summary>
            Creates a new operational observable that multiplies the values in the specified observable by the specified value
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The observable.</param>
      <param name="second">A value that is multiplied against each value in the <paramref name="first" /> observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Multiply(`0)">
      <summary>
            Creates a new operational observable that multiplies the values in the specified observable by the specified <paramref name="value" />.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that is multiplied against each value in this observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Division(System.Reactive.OperationalObservable{`0,`1},System.IObservable{`0})">
      <summary>
            Creates a new operational observable that divides the values in the specified observables 
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first observable.</param>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Divide(System.IObservable{`0})">
      <summary>
            Creates a new operational observable that divides the values in this observable with the values in the specified observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Division(System.Reactive.OperationalObservable{`0,`1},`0)">
      <summary>
            Creates a new operational observable that divides the values in the specified observable by the specified value
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The observable.</param>
      <param name="second">A value that divides each value in the <paramref name="first" /> observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Divide(`0)">
      <summary>
            Creates a new operational observable that divides the values in this observable by the specified <paramref name="value" />.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that divides each value in this observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_UnaryPlus(System.Reactive.OperationalObservable{`0,`1})">
      <summary>
            Creates a new operational observable that ensures the sign of the specified observable's values are positive.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="observable">The observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>observable != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Plus">
      <summary>
            Creates a new operational observable that ensures the sign of this observable's values are positive.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <returns>An operational observable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_UnaryNegation(System.Reactive.OperationalObservable{`0,`1})">
      <summary>
            Creates a new operational observable that ensures the sign of the specified observable's values are negative.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="observable">The observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>observable != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Negate">
      <summary>
            Creates a new operational observable that ensures the sign of this observable's values are negative.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <returns>An operational observable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.OperationalObservable`1">
      <summary>
            Represents an observable that uses its unary and binary operator overloads as observable query operators.
            </summary>
      <typeparam name="T">Input and output type.</typeparam>
    </member>
    <member name="T:System.Reactive.PairedObservableExtensions">
      <summary>
            Provides extension methods for <see cref="T:System.Reactive.IPairedObservable`2" />.
            </summary>
    </member>
    <member name="M:System.Reactive.PairedObservableExtensions.SubscribePair``2(System.IObservable{System.Either{``0,``1}},System.Action{``0},System.Action{``1})">
      <summary>
            Notifies the observable that an observer is to receive notifications.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable for which a subscription is created.</param>
      <param name="onNextLeft">The handler of notifications in the left channel.</param>
      <param name="onNextRight">The handler of notifications in the right channel.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <requires>source != null</requires>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.PairedObservableExtensions.SubscribePair``2(System.IObservable{System.Either{``0,``1}},System.Action{``0},System.Action{``1},System.Action{System.Exception})">
      <summary>
            Notifies the observable that an observer is to receive notifications.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable for which a subscription is created.</param>
      <param name="onNextLeft">The handler of notifications in the left channel.</param>
      <param name="onNextRight">The handler of notifications in the right channel.</param>
      <param name="onError">The handler of an error notification.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <requires>source != null</requires>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <requires>onError != null</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.PairedObservableExtensions.SubscribePair``2(System.IObservable{System.Either{``0,``1}},System.Action{``0},System.Action{``1},System.Action)">
      <summary>
            Notifies the observable that an observer is to receive notifications.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable for which a subscription is created.</param>
      <param name="onNextLeft">The handler of notifications in the left channel.</param>
      <param name="onNextRight">The handler of notifications in the right channel.</param>
      <param name="onCompleted">The handler of a completion notification.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <requires>source != null</requires>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <requires>onCompleted != null</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.PairedObservableExtensions.SubscribePair``2(System.IObservable{System.Either{``0,``1}},System.Action{``0},System.Action{``1},System.Action{System.Exception},System.Action)">
      <summary>
            Notifies the observable that an observer is to receive notifications.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable for which a subscription is created.</param>
      <param name="onNextLeft">The handler of notifications in the left channel.</param>
      <param name="onNextRight">The handler of notifications in the right channel.</param>
      <param name="onError">The handler of an error notification.</param>
      <param name="onCompleted">The handler of a completion notification.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <requires>source != null</requires>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <requires>onError != null</requires>
      <requires>onCompleted != null</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.PairedObserver">
      <summary>
            Provides extension and factory methods for <see cref="T:System.Reactive.IPairedObserver`2" />.
            </summary>
    </member>
    <member name="M:System.Reactive.PairedObserver.Create``2(System.Action{``0},System.Action{``1})">
      <summary>
            Creates an observer that is capable of observing paired observables using the specified actions.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="onNextLeft">Handler for notifications from the left channel.</param>
      <param name="onNextRight">Handler for notifications from the right channel.</param>
      <returns>An observer capable of observing paired observables.</returns>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <ensures>Contract.Result&lt;IPairedObserver&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.PairedObserver.Create``2(System.Action{``0},System.Action{``1},System.Action{System.Exception})">
      <summary>
            Creates an observer that is capable of observing paired observables using the specified actions.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="onNextLeft">Handler for notifications from the left channel.</param>
      <param name="onNextRight">Handler for notifications from the right channel.</param>
      <param name="onError">Handler for an error notification.</param>
      <returns>An observer capable of observing paired observables.</returns>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <requires>onError != null</requires>
      <ensures>Contract.Result&lt;IPairedObserver&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.PairedObserver.Create``2(System.Action{``0},System.Action{``1},System.Action)">
      <summary>
            Creates an observer that is capable of observing paired observables using the specified actions.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="onNextLeft">Handler for notifications from the left channel.</param>
      <param name="onNextRight">Handler for notifications from the right channel.</param>
      <param name="onCompleted">Handler for a completed notification.</param>
      <returns>An observer capable of observing paired observables.</returns>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <requires>onCompleted != null</requires>
      <ensures>Contract.Result&lt;IPairedObserver&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.PairedObserver.Create``2(System.Action{``0},System.Action{``1},System.Action{System.Exception},System.Action)">
      <summary>
            Creates an observer that is capable of observing paired observables using the specified actions.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="onNextLeft">Handler for notifications from the left channel.</param>
      <param name="onNextRight">Handler for notifications from the right channel.</param>
      <param name="onError">Handler for an error notification.</param>
      <param name="onCompleted">Handler for a completed notification.</param>
      <returns>An observer capable of observing paired observables.</returns>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <requires>onError != null</requires>
      <requires>onCompleted != null</requires>
      <ensures>Contract.Result&lt;IPairedObserver&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserQueryContext`3.Rxx#Parsers#IParser{TSource@TResult}#Parse(System.Collections.Generic.IEnumerable{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserQueryContext`3.Rxx#Parsers#IParser{TSource@TResult}#get_StartIndex">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_StartIndex" inheritedFromTypeName="IParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
    </member>
    <member name="P:Rxx.Parsers.ParserQueryContext`3.Rxx#Parsers#IParser{TSource@TResult}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.ParserQueryContext`3.Parser">
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserQueryContext`3.Rxx#Parsers#IParser{TSource@TResult}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.ParserQueryContext`3.Rxx#Parsers#IParser{TSource@TResult}#StartIndex">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_StartIndex" inheritedFromTypeName="IParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserQueryContext`3.#ctor(Rxx.Parsers.IParser{`0,`1},`2)">
      <requires>parser != null</requires>
    </member>
    <member name="M:Rxx.Parsers.AmbiguousParser`2.#ctor(Rxx.Parsers.IParser{`0,`1},System.Func{System.Collections.Generic.IEnumerable{`0},System.Boolean})">
      <requires>parser != null</requires>
      <requires>untilPredicate != null</requires>
    </member>
    <member name="M:Rxx.Parsers.AmbiguousParser`2.Parse">
      <requires inheritedFrom="M:Rxx.Parsers.ParserStartBase`2.Parse" inheritedFromTypeName="ParserStartBase">Cursor != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.ParserStartBase`2.Parse" inheritedFromTypeName="ParserStartBase">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.AmbiguousParser`2.#ctor(Rxx.Parsers.IParser{`0,`1},System.Int32)">
      <requires>parser != null</requires>
      <requires>untilCount &gt;= 0</requires>
    </member>
    <member name="M:Rxx.Parsers.AmbiguousParser`2.CreateCursor(System.Collections.Generic.IEnumerable{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.ParserStartBase`2.CreateCursor(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="ParserStartBase">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.ParserStartBase`2.CreateCursor(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="ParserStartBase">Contract.Result&lt;ParserCursor&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.AmbiguousParser`2.#ctor(Rxx.Parsers.IParser{`0,`1})">
      <requires>parser != null</requires>
    </member>
    <member name="T:Rxx.Parsers.AnyParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="P:Rxx.Parsers.AnyParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AnyParser`2.Parse(System.Collections.Generic.IEnumerable{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.AnyParser`2.StartIndex">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_StartIndex" inheritedFromTypeName="IParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.AnyParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IParser&lt;TSource, TResult&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AnyParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{`0,`1}})">
      <requires>parsers != null</requires>
    </member>
    <member name="T:Rxx.Parsers.ParserCursor`1">
      <invariant>!currentIndex.HasValue || currentIndex.Value &gt;= 0</invariant>
      <invariant>currentIndex.HasValue || getStartIndex != null</invariant>
      <invariant>startIndexOffset &gt;= 0</invariant>
      <invariant>skip &gt;= 0</invariant>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.Completed">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == (input == null &amp;&amp; currentElement == null)</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.Element.MoveNext(System.Collections.Generic.IEnumerator{`0})">
      <requires>enumerator != null</requires>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.GetLastReadElement(System.Int32@)">
      <ensures>Contract.ValueAtReturn(out count) &gt;= 0</ensures>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.StartIndexDebug">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParserCursor`1.get_StartIndexDebug" inheritedFromTypeName="IParserCursor">Contract.Result&lt;string&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.StartIndex">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParserCursor`1.get_StartIndex" inheritedFromTypeName="IParserCursor">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_StartIndex" inheritedFromTypeName="IParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.MoveStartIndex(System.Int32)">
      <requires>count &gt;= 0</requires>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <requires>input != null</requires>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.Parse(System.Collections.Generic.IEnumerable{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{System.Int32})">
      <requires>input != null</requires>
      <requires>getStartIndex != null</requires>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#Word(System.String)">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String)" inheritedFromTypeName="IStringParser">!string.IsNullOrEmpty(value)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#get_AnyCharacter">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_AnyCharacter" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#get_InsignificantWhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.InsignificantWhiteSpaceCached">
      <getter>
        <ensures>Contract.Result&lt;ICollection&lt;char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#AnyCharacterUntil(System.String[])">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#AnyCharacterUntil(System.Char[])">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">stops != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">stops.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#InsignificantWhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#Word(System.String,System.StringComparer)">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String,System.StringComparer)" inheritedFromTypeName="IStringParser">!string.IsNullOrEmpty(value)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String,System.StringComparer)" inheritedFromTypeName="IStringParser">comparer != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String,System.StringComparer)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#AnyCharacter">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_AnyCharacter" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#Character(System.Char)">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Char)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#Character(System.Func{System.Char,System.Boolean})">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringParser">predicate != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#Character(System.Globalization.UnicodeCategory)">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Globalization.UnicodeCategory)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#WhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_WhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#get_WhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_WhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#AnyCharacterUntil(System.StringComparer,System.String[])">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringParser">comparer != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Rxx#Parsers#IParser{System#Char@TResult}#get_StartIndex">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_StartIndex" inheritedFromTypeName="IParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.Rxx#Parsers#IParser{System#Char@TResult}#StartIndex">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_StartIndex" inheritedFromTypeName="IParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.Rxx#Parsers#IParser{System#Char@TResult}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Rxx#Parsers#IParser{System#Char@TResult}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.Parser">
      <getter>
        <ensures>Contract.Result&lt;IXmlParser&lt;TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Rxx#Parsers#IParser{System#Char@TResult}#Parse(System.Collections.Generic.IEnumerable{System.Char})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.#ctor(Rxx.Parsers.IXmlParser{`0},`1)">
      <requires>parser != null</requires>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.Rxx#Parsers#IParser{System#Char@TResult}#get_StartIndex">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_StartIndex" inheritedFromTypeName="IParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
    </member>
    <member name="P:Rxx.Parsers.StringParserQueryContext`2.Rxx#Parsers#IParser{System#Char@TResult}#StartIndex">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_StartIndex" inheritedFromTypeName="IParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.StringParserQueryContext`2.Rxx#Parsers#IParser{System#Char@TResult}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.Rxx#Parsers#IParser{System#Char@TResult}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.StringParserQueryContext`2.Parser">
      <getter>
        <ensures>Contract.Result&lt;IStringParser&lt;TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.Rxx#Parsers#IParser{System#Char@TResult}#Parse(System.Collections.Generic.IEnumerable{System.Char})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.#ctor(Rxx.Parsers.IStringParser{`0},`1)">
      <requires>parser != null</requires>
    </member>
    <member name="P:Rxx.Parsers.IParserCursor`1.StartIndexDebug">
      <getter>
        <ensures>Contract.Result&lt;string&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.IParserCursor`1.StartIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.AllParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="P:Rxx.Parsers.AllParser`2.StartIndex">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_StartIndex" inheritedFromTypeName="IParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.AllParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AllParser`2.Parse(System.Collections.Generic.IEnumerable{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.AllParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IParser&lt;TSource, TResult&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AllParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{`0,`1}})">
      <requires>parsers != null</requires>
    </member>
    <member name="T:Rxx.Parsers.AllManyParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="P:Rxx.Parsers.AllManyParser`2.StartIndex">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_StartIndex" inheritedFromTypeName="IParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AllManyParser`2.Parse(System.Collections.Generic.IEnumerable{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.AllManyParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.AllManyParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AllManyParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{`0,System.Collections.Generic.IEnumerable{`1}}})">
      <requires>parsers != null</requires>
    </member>
    <member name="P:Rxx.Parsers.ParserStartBase`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserStartBase`2.CreateCursor(System.Collections.Generic.IEnumerable{`0})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;ParserCursor&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserStartBase`2.Parse">
      <requires>Cursor != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.ParserStartBase`2.Cursor">
      <getter>
        <ensures>Contract.Result&lt;ParserCursor&lt;TSource&gt;&gt;() == cursor</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.ParserStartBase`2.StartIndex">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_StartIndex" inheritedFromTypeName="IParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserStartBase`2.Parse(System.Collections.Generic.IEnumerable{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.InlineXmlParser`1">
      <invariant>schema != null</invariant>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#CData">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_CData" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Text">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Text" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#get_AnyAttribute">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Attribute(System.String)">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IParser{System#Char@System#Char}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#get_Comment">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Comment" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XComment&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#get_CData">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_CData" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XCData&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#AnyContent">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyContent" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Parse(System.Collections.Generic.IEnumerable{System.Char},Rxx.Parsers.IParser{System.Char,`0})">
      <requires>source != null</requires>
      <requires>grammar != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IParser{System#Char@System#Char}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#AnyElement">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyElement" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Comment">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Comment" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#get_Text">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Text" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XText&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#get_AnyElement">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyElement" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#get_AnyContent">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyContent" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IParser{System#Char@System#Char}#get_StartIndex">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_StartIndex" inheritedFromTypeName="IParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IParser{System#Char@System#Char}#Parse(System.Collections.Generic.IEnumerable{System.Char})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IParser{System#Char@System#Char}#StartIndex">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_StartIndex" inheritedFromTypeName="IParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#AnyAttribute">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Schema">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.XmlParser`1.get_Schema" inheritedFromTypeName="XmlParser">Contract.Result&lt;IParser&lt;char, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AmbiguousGroupRun``1(System.Int32@,System.Collections.Generic.IEnumerable{``0},Rxx.Parsers.IParser{``0,``0},Rxx.Parsers.IParser{``0,``0},System.Collections.Generic.List{System.Action{Rxx.Parsers.IParseResult{``0}}},System.Collections.Generic.List{System.Action{Rxx.Parsers.IParseResult{``0}}},System.Collections.Generic.List{System.Action{Rxx.Parsers.IParseResult{``0}}})">
      <requires>source != null</requires>
      <requires>open != null</requires>
      <requires>close != null</requires>
      <requires>openSinks != null</requires>
      <requires>closeSinks != null</requires>
      <requires>contentSinks != null</requires>
    </member>
    <member name="M:Rxx.Parsers.Parser`2.Rxx#Parsers#IParser{TSource@TResult}#Parse(System.Collections.Generic.IEnumerable{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Attribute(System.String)">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#get_Comment">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Comment" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XComment&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Content(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}})">
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, IEnumerable&lt;XObject&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Content(System.Func{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XText},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XText}},System.Boolean)">
      <requires>textSelector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#get_AnyAttribute">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#get_CData">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_CData" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XCData&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Text">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Text" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Comment">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Comment" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(System.Func{System.String,System.Boolean},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires>name != null</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#AnyAttribute">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#AnyContent">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyContent" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#get_AnyElement">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyElement" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#get_Text">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Text" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XText&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#get_AnyContent">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyContent" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#CData">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_CData" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#AnyElement">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyElement" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(System.Func{System.String,System.Boolean},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}})">
      <requires>name != null</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.AnonymousParser`2">
      <invariant>name == null || name.Length &gt; 0</invariant>
      <invariant>parse != null || parserFactory != null</invariant>
      <invariant>getStartIndex != null</invariant>
      <invariant>getNext != null</invariant>
    </member>
    <member name="P:Rxx.Parsers.AnonymousParser`2.StartIndex">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_StartIndex" inheritedFromTypeName="IParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AnonymousParser`2.#ctor(System.String,System.Func{Rxx.Parsers.IParser{`0,`1}})">
      <requires>name == null || name.Length &gt; 0</requires>
      <requires>parserFactory != null</requires>
    </member>
    <member name="P:Rxx.Parsers.AnonymousParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AnonymousParser`2.Parse(System.Collections.Generic.IEnumerable{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.AnonymousParser`2.#ctor(System.String,System.Func{System.Int32},System.Func{Rxx.Parsers.IParser{`0,`0}},System.Func{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{`1}}})">
      <requires>name == null || name.Length &gt; 0</requires>
      <requires>getStartIndex != null</requires>
      <requires>getNext != null</requires>
      <requires>parse != null</requires>
    </member>
    <member name="T:Rxx.Parsers.InlineParser`2">
      <invariant>start != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.InlineParser`2.Parse(System.Collections.Generic.IEnumerable{`0},Rxx.Parsers.IParser{`0,`1})">
      <requires>source != null</requires>
      <requires>grammar != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineParser`2.Rxx#Parsers#IParser{TSource@TSource}#Parse(System.Collections.Generic.IEnumerable{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineParser`2.Rxx#Parsers#IParser{TSource@TSource}#StartIndex">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_StartIndex" inheritedFromTypeName="IParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineParser`2.Rxx#Parsers#IParser{TSource@TSource}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineParser`2.Rxx#Parsers#IParser{TSource@TSource}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineParser`2.Rxx#Parsers#IParser{TSource@TSource}#get_StartIndex">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_StartIndex" inheritedFromTypeName="IParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineParser`2.Start">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Parser`2.get_Start" inheritedFromTypeName="Parser">Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.ParseResult`1">
      <invariant>length &gt;= 0</invariant>
    </member>
    <member name="P:Rxx.Parsers.ParseResult`1.Length">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParseResult`1.get_Length" inheritedFromTypeName="IParseResult">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParseResult`1.#ctor(System.Int32)">
      <requires>length &gt;= 0</requires>
    </member>
    <member name="M:Rxx.Parsers.ParseResult`1.#ctor(`0,System.Int32)">
      <requires>length &gt;= 0</requires>
    </member>
    <member name="T:Rxx.Parsers.Reactive.InlineStringObservableParser`1">
      <invariant>start != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#Word(System.String,System.StringComparer)">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String,System.StringComparer)" inheritedFromTypeName="IStringObservableParser">!string.IsNullOrEmpty(value)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String,System.StringComparer)" inheritedFromTypeName="IStringObservableParser">comparer != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String,System.StringComparer)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#Character(System.Func{System.Char,System.Boolean})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringObservableParser">predicate != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IObservableParser{System#Char@System#Char}#StartIndex">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_StartIndex" inheritedFromTypeName="IObservableParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IObservableParser{System#Char@System#Char}#Parse(System.IObservable{System.Char})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#AnyCharacterUntil(System.StringComparer,System.String[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringObservableParser">comparer != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#Character(System.Char)">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Char)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Start">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.ObservableParser`2.get_Start" inheritedFromTypeName="ObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#AnyCharacterUntil(System.String[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IObservableParser{System#Char@System#Char}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IObservableParser{System#Char@System#Char}#get_StartIndex">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_StartIndex" inheritedFromTypeName="IObservableParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#WhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_WhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#get_InsignificantWhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#get_AnyCharacter">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_AnyCharacter" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#get_WhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_WhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#Character(System.Globalization.UnicodeCategory)">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Globalization.UnicodeCategory)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#AnyCharacter">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_AnyCharacter" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Parse(System.IObservable{System.Char},Rxx.Parsers.Reactive.IObservableParser{System.Char,`0})">
      <requires>source != null</requires>
      <requires>grammar != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#InsignificantWhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#Word(System.String)">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String)" inheritedFromTypeName="IStringObservableParser">!string.IsNullOrEmpty(value)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#AnyCharacterUntil(System.Char[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">stops != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">stops.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IObservableParser{System#Char@System#Char}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserQueryContext`3.Rxx#Parsers#Reactive#IObservableParser{TSource@TResult}#StartIndex">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_StartIndex" inheritedFromTypeName="IObservableParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserQueryContext`3.Rxx#Parsers#Reactive#IObservableParser{TSource@TResult}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserQueryContext`3.Rxx#Parsers#Reactive#IObservableParser{TSource@TResult}#get_StartIndex">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_StartIndex" inheritedFromTypeName="IObservableParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserQueryContext`3.Parser">
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserQueryContext`3.Rxx#Parsers#Reactive#IObservableParser{TSource@TResult}#Parse(System.IObservable{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserQueryContext`3.Rxx#Parsers#Reactive#IObservableParser{TSource@TResult}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserQueryContext`3.#ctor(Rxx.Parsers.Reactive.IObservableParser{`0,`1},`2)">
      <requires>parser != null</requires>
    </member>
    <member name="T:Rxx.Parsers.Reactive.AnonymousObservableParser`2">
      <invariant>name == null || name.Length &gt; 0</invariant>
      <invariant>parse != null || parserFactory != null</invariant>
      <invariant>getStartIndex != null</invariant>
      <invariant>getNext != null</invariant>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AnonymousObservableParser`2.StartIndex">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_StartIndex" inheritedFromTypeName="IObservableParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AnonymousObservableParser`2.#ctor(System.String,System.Func{Rxx.Parsers.Reactive.IObservableParser{`0,`1}})">
      <requires>name == null || name.Length &gt; 0</requires>
      <requires>parserFactory != null</requires>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AnonymousObservableParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AnonymousObservableParser`2.Parse(System.IObservable{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AnonymousObservableParser`2.#ctor(System.String,System.Func{System.Int32},System.Func{Rxx.Parsers.Reactive.IObservableParser{`0,`0}},System.Func{System.IObservable{`0},System.IObservable{Rxx.Parsers.IParseResult{`1}}})">
      <requires>name == null || name.Length &gt; 0</requires>
      <requires>getStartIndex != null</requires>
      <requires>getNext != null</requires>
      <requires>parse != null</requires>
    </member>
    <member name="T:Rxx.Parsers.Reactive.AllManyObservableParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AllManyObservableParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AllManyObservableParser`2.Parse(System.IObservable{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AllManyObservableParser`2.StartIndex">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_StartIndex" inheritedFromTypeName="IObservableParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AllManyObservableParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AllManyObservableParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{`0,System.IObservable{`1}}})">
      <requires>parsers != null</requires>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Rxx#Parsers#Reactive#IObservableParser{System#Char@TResult}#StartIndex">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_StartIndex" inheritedFromTypeName="IObservableParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Rxx#Parsers#Reactive#IObservableParser{System#Char@TResult}#Parse(System.IObservable{System.Char})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Rxx#Parsers#Reactive#IObservableParser{System#Char@TResult}#get_StartIndex">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_StartIndex" inheritedFromTypeName="IObservableParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Rxx#Parsers#Reactive#IObservableParser{System#Char@TResult}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Rxx#Parsers#Reactive#IObservableParser{System#Char@TResult}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Parser">
      <getter>
        <ensures>Contract.Result&lt;IStringObservableParser&lt;TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.#ctor(Rxx.Parsers.Reactive.IStringObservableParser{`0},`1)">
      <requires>parser != null</requires>
    </member>
    <member name="T:Rxx.Parsers.Reactive.ParserSubject`1">
      <invariant>gate != null</invariant>
      <invariant>observers != null</invariant>
      <invariant>elements != null</invariant>
      <invariant>startIndexOffset &gt;= 0</invariant>
      <invariant>skip &gt;= 0</invariant>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ParserSubject`1.StartIndexDebug">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParserCursor`1.get_StartIndexDebug" inheritedFromTypeName="IParserCursor">Contract.Result&lt;string&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ParserSubject`1.StartIndex">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParserCursor`1.get_StartIndex" inheritedFromTypeName="IParserCursor">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_StartIndex" inheritedFromTypeName="IObservableParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ParserSubject`1.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ParserSubject`1.MoveStartIndex(System.Int32)">
      <requires>count &gt;= 0</requires>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ParserSubject`1.Parse(System.IObservable{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ParserSubject`1.#ctor(System.Func{System.Int32})">
      <requires>getStartIndex != null</requires>
    </member>
    <member name="T:Rxx.Parsers.Reactive.AnyObservableParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AnyObservableParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AnyObservableParser`2.Parse(System.IObservable{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AnyObservableParser`2.StartIndex">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_StartIndex" inheritedFromTypeName="IObservableParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AnyObservableParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IObservableParser&lt;TSource, TResult&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AnyObservableParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{`0,`1}})">
      <requires>parsers != null</requires>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.SelectManyInternal``4(System.IObservable{``0},Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,System.IObservable{``2}},System.Func{``1,``2,``3},System.Func{Rxx.Parsers.IParseResult{``1},``2,System.Int32})">
      <requires>source != null</requires>
      <requires>parser != null</requires>
      <requires>collectionSelector != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.SelectManyInternal``4(System.IObservable{``0},Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,Rxx.Parsers.Reactive.IObservableParser{``0,``2}},System.Func{``1,``2,``3},System.Func{Rxx.Parsers.IParseResult{``1},Rxx.Parsers.IParseResult{``2},System.Int32})">
      <requires>source != null</requires>
      <requires>firstParser != null</requires>
      <requires>secondSelector != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AmbiguousGroupInternal``1(System.IObservable{``0},Rxx.Parsers.Reactive.IObservableParser{``0,``0},Rxx.Parsers.Reactive.IObservableParser{``0,``0})">
      <requires>source != null</requires>
      <requires>open != null</requires>
      <requires>close != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;IObservable&lt;TSource&gt;&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserStartBase`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserStartBase`2.Cursor">
      <getter>
        <ensures>Contract.Result&lt;ParserSubject&lt;TSource&gt;&gt;() == cursor</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserStartBase`2.Parse">
      <requires>Cursor != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserStartBase`2.StartIndex">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_StartIndex" inheritedFromTypeName="IObservableParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserStartBase`2.Parse(System.IObservable{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserStartBase`2.CreateSubject">
      <ensures>Contract.Result&lt;ParserSubject&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.AllObservableParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AllObservableParser`2.StartIndex">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_StartIndex" inheritedFromTypeName="IObservableParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AllObservableParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AllObservableParser`2.Parse(System.IObservable{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AllObservableParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IObservableParser&lt;TSource, TResult&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AllObservableParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{`0,`1}})">
      <requires>parsers != null</requires>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AmbiguousObservableParser`3.#ctor(Rxx.Parsers.Reactive.IObservableParser{`0,`2},Rxx.Parsers.Reactive.IObservableParser{`0,`1})">
      <requires>parser != null</requires>
      <requires>untilParser != null</requires>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AmbiguousObservableParser`3.Parse">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.ObservableParserStartBase`2.Parse" inheritedFromTypeName="ObservableParserStartBase">Cursor != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.ObservableParserStartBase`2.Parse" inheritedFromTypeName="ObservableParserStartBase">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AmbiguousObservableParser`3.CreateSubject">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.ObservableParserStartBase`2.CreateSubject" inheritedFromTypeName="ObservableParserStartBase">Contract.Result&lt;ParserSubject&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AmbiguousObservableParser`3.#ctor(Rxx.Parsers.Reactive.IObservableParser{`0,`2},System.Int32)">
      <requires>parser != null</requires>
      <requires>untilCount &gt;= 0</requires>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AmbiguousObservableParser`3.#ctor(Rxx.Parsers.Reactive.IObservableParser{`0,`2})">
      <requires>parser != null</requires>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#get_AnyCharacter">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_AnyCharacter" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#AnyCharacterUntil(System.String[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#Word(System.String)">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String)" inheritedFromTypeName="IStringObservableParser">!string.IsNullOrEmpty(value)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#get_WhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_WhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#AnyCharacter">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_AnyCharacter" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#Character(System.Char)">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Char)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#get_InsignificantWhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#AnyCharacterUntil(System.Char[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">stops != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">stops.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#InsignificantWhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.InsignificantWhiteSpaceCached">
      <getter>
        <ensures>Contract.Result&lt;ICollection&lt;char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#Character(System.Func{System.Char,System.Boolean})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringObservableParser">predicate != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#Word(System.String,System.StringComparer)">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String,System.StringComparer)" inheritedFromTypeName="IStringObservableParser">!string.IsNullOrEmpty(value)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String,System.StringComparer)" inheritedFromTypeName="IStringObservableParser">comparer != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String,System.StringComparer)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#AnyCharacterUntil(System.StringComparer,System.String[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringObservableParser">comparer != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#WhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_WhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#Character(System.Globalization.UnicodeCategory)">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Globalization.UnicodeCategory)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.InlineObservableParser`2">
      <invariant>start != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineObservableParser`2.Rxx#Parsers#Reactive#IObservableParser{TSource@TSource}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineObservableParser`2.Parse(System.IObservable{`0},Rxx.Parsers.Reactive.IObservableParser{`0,`1})">
      <requires>source != null</requires>
      <requires>grammar != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineObservableParser`2.Rxx#Parsers#Reactive#IObservableParser{TSource@TSource}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineObservableParser`2.Rxx#Parsers#Reactive#IObservableParser{TSource@TSource}#Parse(System.IObservable{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineObservableParser`2.Rxx#Parsers#Reactive#IObservableParser{TSource@TSource}#get_StartIndex">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_StartIndex" inheritedFromTypeName="IObservableParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineObservableParser`2.Rxx#Parsers#Reactive#IObservableParser{TSource@TSource}#StartIndex">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_StartIndex" inheritedFromTypeName="IObservableParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineObservableParser`2.Start">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.ObservableParser`2.get_Start" inheritedFromTypeName="ObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParser`2.Rxx#Parsers#Reactive#IObservableParser{TSource@TResult}#Parse(System.IObservable{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.IObservable{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserStart`2.Parse">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.ObservableParserStartBase`2.Parse" inheritedFromTypeName="ObservableParserStartBase">Cursor != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.ObservableParserStartBase`2.Parse" inheritedFromTypeName="ObservableParserStartBase">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserStart`2.StartIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == 0</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserStart`2.#ctor(System.Func{Rxx.Parsers.Reactive.IObservableParser{`0,`0},Rxx.Parsers.Reactive.IObservableParser{`0,`1}})">
      <requires>grammar != null</requires>
    </member>
    <member name="M:Rxx.Parsers.ParserStart`2.Parse">
      <requires inheritedFrom="M:Rxx.Parsers.ParserStartBase`2.Parse" inheritedFromTypeName="ParserStartBase">Cursor != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.ParserStartBase`2.Parse" inheritedFromTypeName="ParserStartBase">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.ParserStart`2.StartIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == 0</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserStart`2.#ctor(System.Func{Rxx.Parsers.IParser{`0,`0},Rxx.Parsers.IParser{`0,`1}})">
      <requires>grammar != null</requires>
    </member>
    <member name="T:Rxx.Parsers.InlineStringParser`1">
      <invariant>start != null</invariant>
    </member>
    <member name="P:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IParser{System#Char@System#Char}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#Character(System.Globalization.UnicodeCategory)">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Globalization.UnicodeCategory)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#Character(System.Char)">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Char)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#AnyCharacterUntil(System.Char[])">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">stops != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">stops.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#AnyCharacter">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_AnyCharacter" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#AnyCharacterUntil(System.String[])">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#get_WhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_WhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineStringParser`1.Start">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Parser`2.get_Start" inheritedFromTypeName="Parser">Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#InsignificantWhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#WhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_WhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IParser{System#Char@System#Char}#get_StartIndex">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_StartIndex" inheritedFromTypeName="IParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IParser{System#Char@System#Char}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#Word(System.String)">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String)" inheritedFromTypeName="IStringParser">!string.IsNullOrEmpty(value)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#get_AnyCharacter">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_AnyCharacter" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#Word(System.String,System.StringComparer)">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String,System.StringComparer)" inheritedFromTypeName="IStringParser">!string.IsNullOrEmpty(value)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String,System.StringComparer)" inheritedFromTypeName="IStringParser">comparer != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String,System.StringComparer)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#get_InsignificantWhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#Character(System.Func{System.Char,System.Boolean})">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringParser">predicate != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IParser{System#Char@System#Char}#Parse(System.Collections.Generic.IEnumerable{System.Char})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IParser{System#Char@System#Char}#StartIndex">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_StartIndex" inheritedFromTypeName="IParser">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Parse(System.Collections.Generic.IEnumerable{System.Char},Rxx.Parsers.IParser{System.Char,`0})">
      <requires>source != null</requires>
      <requires>grammar != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#AnyCharacterUntil(System.StringComparer,System.String[])">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringParser">comparer != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.StringComparer,System.String[])" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.ComponentReflection.GetEvent(System.Object,System.String,System.StringComparison)">
      <requires>source != null</requires>
      <requires>eventName != null</requires>
    </member>
    <member name="M:Rxx.ComponentReflection.GetEvents(System.Object)">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;EventDescriptor&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.ComponentReflection.GetProperties(System.Object)">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;PropertyDescriptor&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.ComponentReflection.GetProperty(System.Object,System.String,System.StringComparison)">
      <requires>source != null</requires>
      <requires>propertyName != null</requires>
    </member>
    <member name="M:Rxx.ComponentReflection.GetMembers(System.Object)">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;MemberDescriptor&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.AsyncResult`1">
      <invariant>gate != null</invariant>
    </member>
    <member name="P:Rxx.AsyncResult`1.CompletedSynchronously">
      <getter>
        <requires>gate != null</requires>
      </getter>
      <setter>
        <requires>gate != null</requires>
      </setter>
    </member>
    <member name="P:Rxx.AsyncResult`1.AsyncWaitHandle">
      <getter>
        <ensures>Contract.Result&lt;WaitHandle&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.AsyncResult`1.OutOfBandData">
      <getter>
        <requires>gate != null</requires>
      </getter>
      <setter>
        <requires>gate != null</requires>
      </setter>
    </member>
    <member name="P:Rxx.AsyncResult`1.IsCompleted">
      <getter>
        <requires>gate != null</requires>
      </getter>
      <setter>
        <requires>gate != null</requires>
      </setter>
    </member>
    <member name="M:System.Tuple.Create``3(``0,``1,``2)">
      <ensures>Contract.Result&lt;Tuple&lt;T1, T2, T3&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Tuple.Create``2(``0,``1)">
      <ensures>Contract.Result&lt;Tuple&lt;T1, T2&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Tuple`3.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.UnaryOperation(System.Func{`0,`1})">
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0},System.Func{`0,`0,`1},System.Collections.Generic.IEnumerable{`1}},System.Func{`0,`0,`1},System.Func{`0,`0,`1},System.Func{`0,`0,`1},System.Func{`0,`0,`1},System.Func{`0,`1},System.Func{`0,`1},System.Func{System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.OperationalEnumerable{`1}})">
      <requires>source != null</requires>
      <requires>resultSelector != null</requires>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.BinaryOperation(`0,System.Func{`0,`0,`1})">
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.DefaultBinaryOperation(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0},System.Func{`0,`0,`1})">
      <requires>first != null</requires>
      <requires>second != null</requires>
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.BinaryOperation(System.Collections.Generic.IEnumerable{`0},System.Func{`0,`0,`1})">
      <requires>second != null</requires>
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0},System.Func{`0,`0,`0},System.Collections.Generic.IEnumerable{`0}},System.Func{`0,`0,`0},System.Func{`0,`0,`0},System.Func{`0,`0,`0},System.Func{`0,`0,`0},System.Func{`0,`0},System.Func{`0,`0})">
      <requires>source != null</requires>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Int16},System.Func{System.Collections.Generic.IEnumerable{System.Int16},System.Collections.Generic.IEnumerable{System.Int16},System.Func{System.Int16,System.Int16,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Decimal},System.Func{System.Collections.Generic.IEnumerable{System.Decimal},System.Collections.Generic.IEnumerable{System.Decimal},System.Func{System.Decimal,System.Decimal,System.Decimal},System.Collections.Generic.IEnumerable{System.Decimal}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;decimal&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.UInt32},System.Func{System.Collections.Generic.IEnumerable{System.UInt32},System.Collections.Generic.IEnumerable{System.UInt32},System.Func{System.UInt32,System.UInt32,System.UInt32},System.Collections.Generic.IEnumerable{System.UInt32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;uint&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.SByte},System.Func{System.Collections.Generic.IEnumerable{System.SByte},System.Collections.Generic.IEnumerable{System.SByte},System.Func{System.SByte,System.SByte,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Int64},System.Func{System.Collections.Generic.IEnumerable{System.Int64},System.Collections.Generic.IEnumerable{System.Int64},System.Func{System.Int64,System.Int64,System.Int64},System.Collections.Generic.IEnumerable{System.Int64}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;long&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.UInt64},System.Func{System.Collections.Generic.IEnumerable{System.UInt64},System.Collections.Generic.IEnumerable{System.UInt64},System.Func{System.UInt64,System.UInt64,System.UInt64},System.Collections.Generic.IEnumerable{System.UInt64}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;ulong&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Single},System.Func{System.Collections.Generic.IEnumerable{System.Single},System.Collections.Generic.IEnumerable{System.Single},System.Func{System.Single,System.Single,System.Single},System.Collections.Generic.IEnumerable{System.Single}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;float&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Byte},System.Func{System.Collections.Generic.IEnumerable{System.Byte},System.Collections.Generic.IEnumerable{System.Byte},System.Func{System.Byte,System.Byte,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Double},System.Func{System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Func{System.Double,System.Double,System.Double},System.Collections.Generic.IEnumerable{System.Double}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;double&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.UInt16},System.Func{System.Collections.Generic.IEnumerable{System.UInt16},System.Collections.Generic.IEnumerable{System.UInt16},System.Func{System.UInt16,System.UInt16,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Char},System.Func{System.Collections.Generic.IEnumerable{System.Char},System.Collections.Generic.IEnumerable{System.Char},System.Func{System.Char,System.Char,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Linq.Enumerable2.ThrowingEnumerable`1">
      <invariant>enumerator != null</invariant>
    </member>
    <member name="M:System.Linq.Enumerable2.ThrowingEnumerable`1.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="T:System.Linq.Enumerable2.ThrowingEnumerable`1.ThrowingEnumerator">
      <invariant>exception != null</invariant>
    </member>
    <member name="M:System.Linq.Enumerable2.ThrowingEnumerable`1.ThrowingEnumerator.MoveNext">
      <ensures inheritedFrom="M:System.Collections.IEnumerator.MoveNext" inheritedFromTypeName="IEnumerator">this.Model == Contract.OldValue(this.Model)</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerator.MoveNext" inheritedFromTypeName="IEnumerator">this.CurrentIndex &lt; this.Model.Length</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerator.MoveNext" inheritedFromTypeName="IEnumerator">this.CurrentIndex &gt;= 0</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerator.MoveNext" inheritedFromTypeName="IEnumerator">this.CurrentIndex == Contract.OldValue(this.CurrentIndex) + 1</ensures>
    </member>
    <member name="P:System.Linq.Enumerable2.ThrowingEnumerable`1.ThrowingEnumerator.Current">
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IEnumerator`1.get_Current" inheritedFromTypeName="IEnumerator">(object)Contract.Result&lt;T&gt;() == this.Model[this.CurrentIndex]</ensures>
      </getter>
    </member>
    <member name="M:System.Linq.Enumerable2.ThrowingEnumerable`1.ThrowingEnumerator.System#Collections#IEnumerator#get_Current">
      <ensures inheritedFrom="M:System.Collections.IEnumerator.get_Current" inheritedFromTypeName="IEnumerator">Contract.Result&lt;object&gt;() == this.Model[this.CurrentIndex]</ensures>
    </member>
    <member name="P:System.Linq.Enumerable2.ThrowingEnumerable`1.ThrowingEnumerator.System#Collections#IEnumerator#Current">
      <getter>
        <ensures inheritedFrom="M:System.Collections.IEnumerator.get_Current" inheritedFromTypeName="IEnumerator">Contract.Result&lt;object&gt;() == this.Model[this.CurrentIndex]</ensures>
      </getter>
    </member>
    <member name="M:System.Linq.Enumerable2.ThrowingEnumerable`1.ThrowingEnumerator.#ctor(System.Exception)">
      <requires>exception != null</requires>
    </member>
    <member name="M:System.Linq.Enumerable2.ThrowingEnumerable`1.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:System.Linq.Enumerable2.ThrowingEnumerable`1.#ctor(System.Exception)">
      <requires>exception != null</requires>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionExtensions.GetOwner(System.Linq.Expressions.MemberExpression)">
      <requires>property != null</requires>
      <ensures>Contract.Result&lt;object&gt;() != null</ensures>
    </member>
    <member name="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object)">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;EventDescriptor&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object)">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;PropertyDescriptor&gt;&gt;() != null</ensures>
    </member>
    <member name="P:System.ComponentModel.MemberDescriptor.Name">
      <getter>
        <ensures>!string.IsNullOrEmpty(Contract.Result&lt;string&gt;())</ensures>
      </getter>
    </member>
    <member name="T:System.ComponentModel.PropertyDescriptor">
      <invariant>property != null</invariant>
    </member>
    <member name="P:System.ComponentModel.PropertyDescriptor.PropertyType">
      <getter>
        <ensures>Contract.Result&lt;Type&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:System.ComponentModel.PropertyDescriptor.Name">
      <getter>
        <ensures inheritedFrom="M:System.ComponentModel.MemberDescriptor.get_Name" inheritedFromTypeName="MemberDescriptor">!string.IsNullOrEmpty(Contract.Result&lt;string&gt;())</ensures>
      </getter>
    </member>
    <member name="M:System.ComponentModel.PropertyDescriptor.EnsureChangeEvent">
      <ensures>Contract.Result&lt;bool&gt;() == (changeEvent != null)</ensures>
    </member>
    <member name="M:System.ComponentModel.PropertyDescriptor.#ctor(System.Reflection.PropertyInfo)">
      <requires>property != null</requires>
    </member>
    <member name="T:System.ComponentModel.EventDescriptor">
      <invariant>@event != null</invariant>
    </member>
    <member name="P:System.ComponentModel.EventDescriptor.EventType">
      <getter>
        <ensures>Contract.Result&lt;Type&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:System.ComponentModel.EventDescriptor.Name">
      <getter>
        <ensures inheritedFrom="M:System.ComponentModel.MemberDescriptor.get_Name" inheritedFromTypeName="MemberDescriptor">!string.IsNullOrEmpty(Contract.Result&lt;string&gt;())</ensures>
      </getter>
    </member>
    <member name="M:System.ComponentModel.EventDescriptor.#ctor(System.Reflection.EventInfo)">
      <requires>@event != null</requires>
    </member>
    <member name="T:System.Lazy`1">
      <invariant>valueFactory != null</invariant>
    </member>
    <member name="M:System.Lazy`1.#ctor(System.Func{`0})">
      <requires>valueFactory != null</requires>
    </member>
    <member name="M:System.Tuple`2.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`1.#ctor(System.IObservable{`0},System.Func{System.IObservable{`0},System.IObservable{`0},System.Func{`0,`0,`0},System.IObservable{`0}},System.Func{`0,`0,`0},System.Func{`0,`0,`0},System.Func{`0,`0,`0},System.Func{`0,`0,`0},System.Func{`0,`0},System.Func{`0,`0})">
      <requires>source != null</requires>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.UnaryOperation(System.Func{`0,`1})">
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.#ctor(System.IObservable{`0},System.Func{System.IObservable{`0},System.IObservable{`0},System.Func{`0,`0,`1},System.IObservable{`1}},System.Func{`0,`0,`1},System.Func{`0,`0,`1},System.Func{`0,`0,`1},System.Func{`0,`0,`1},System.Func{`0,`1},System.Func{`0,`1},System.Func{System.IObservable{`1},System.Reactive.OperationalObservable{`1}})">
      <requires>source != null</requires>
      <requires>resultSelector != null</requires>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.BinaryOperation(System.IObservable{`0},System.Func{`0,`0,`1})">
      <requires>second != null</requires>
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.DefaultBinaryOperation(System.IObservable{`0},System.IObservable{`0},System.Func{`0,`0,`1})">
      <requires>first != null</requires>
      <requires>second != null</requires>
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.BinaryOperation(`0,System.Func{`0,`0,`1})">
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.AnonymousPairedObservable`2">
      <invariant>observable != null</invariant>
    </member>
    <member name="M:System.Reactive.AnonymousPairedObservable`2.Subscribe(System.Reactive.IPairedObserver{`0,`1})">
      <requires inheritedFrom="M:System.Reactive.IPairedObservable`2.Subscribe(System.Reactive.IPairedObserver{`0,`1})" inheritedFromTypeName="IPairedObservable">observer != null</requires>
      <ensures inheritedFrom="M:System.Reactive.IPairedObservable`2.Subscribe(System.Reactive.IPairedObserver{`0,`1})" inheritedFromTypeName="IPairedObservable">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.FromEventBasedAsyncPattern``2(System.Func{System.EventHandler{``1},``0},System.Action{``0},System.Action{``0},System.Action{System.Object},System.Action,System.Action)">
      <requires>conversion != null</requires>
      <requires>addHandler != null</requires>
      <requires>removeHandler != null</requires>
      <requires>start != null</requires>
      <requires>cancel != null</requires>
      <requires>canceledOrCompleted != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;TEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.UsingHot``2(``1,System.Func{``1,System.IObservable{``0}})">
      <requires>resource != null</requires>
      <requires>hotObservableFactory != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.GetDefaultMaxConcurrent">
      <ensures>Contract.Result&lt;int&gt;() &gt; 0</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.FromPropertyChangedPattern(System.Object,System.Func{System.Reflection.PropertyInfo})">
      <requires>source != null</requires>
      <requires>getPropertyInfo != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;PropertyChangedEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Int16},System.Func{System.IObservable{System.Int16},System.IObservable{System.Int16},System.Func{System.Int16,System.Int16,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Int32},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Decimal},System.Func{System.IObservable{System.Decimal},System.IObservable{System.Decimal},System.Func{System.Decimal,System.Decimal,System.Decimal},System.IObservable{System.Decimal}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;decimal&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.UInt32},System.Func{System.IObservable{System.UInt32},System.IObservable{System.UInt32},System.Func{System.UInt32,System.UInt32,System.UInt32},System.IObservable{System.UInt32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;uint&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.SByte},System.Func{System.IObservable{System.SByte},System.IObservable{System.SByte},System.Func{System.SByte,System.SByte,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Int64},System.Func{System.IObservable{System.Int64},System.IObservable{System.Int64},System.Func{System.Int64,System.Int64,System.Int64},System.IObservable{System.Int64}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;long&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.UInt64},System.Func{System.IObservable{System.UInt64},System.IObservable{System.UInt64},System.Func{System.UInt64,System.UInt64,System.UInt64},System.IObservable{System.UInt64}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;ulong&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Single},System.Func{System.IObservable{System.Single},System.IObservable{System.Single},System.Func{System.Single,System.Single,System.Single},System.IObservable{System.Single}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;float&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Byte},System.Func{System.IObservable{System.Byte},System.IObservable{System.Byte},System.Func{System.Byte,System.Byte,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Double},System.Func{System.IObservable{System.Double},System.IObservable{System.Double},System.Func{System.Double,System.Double,System.Double},System.IObservable{System.Double}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;double&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.UInt16},System.Func{System.IObservable{System.UInt16},System.IObservable{System.UInt16},System.Func{System.UInt16,System.UInt16,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Char},System.Func{System.IObservable{System.Char},System.IObservable{System.Char},System.Func{System.Char,System.Char,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.AnonymousPairedObserver`2">
      <invariant>observer != null</invariant>
    </member>
    <member name="T:System.Reactive.Subjects.ReconnectableObservable`2">
      <invariant>gate != null</invariant>
      <invariant>source != null</invariant>
      <invariant>factory != null</invariant>
    </member>
    <member name="P:System.Reactive.Subjects.ReconnectableObservable`2.Subject">
      <getter>
        <ensures>Contract.Result&lt;ISubject&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.Subjects.ReconnectableObservable`2.#ctor(System.IObservable{`0},System.Func{System.Reactive.Subjects.ISubject{`0,`1}})">
      <requires>source != null</requires>
      <requires>factory != null</requires>
    </member>
  </members>
</doc>